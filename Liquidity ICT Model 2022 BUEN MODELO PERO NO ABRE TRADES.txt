//+------------------------------------------------------------------+
//|                   Liquidity ICT Model 2022.mq5                   |
//|           EA Basado en Conceptos Avanzados de ICT 2022           |
//|      Refactorización y Mejora de "Liquidity 7.0 VOLATILIDAD"     |
//|                          Desarrollado por IA                     |
//+------------------------------------------------------------------+
#property strict
#property version   "2.00" // Versión del Modelo ICT 2022
#property description "Asesor Experto avanzado utilizando conceptos ICT 2022 para la selección"
#property description "de POIs, entradas confirmadas, gestión de trades y análisis de liquidez."

#include <Trade\Trade.mqh> // Para operaciones de trading
CTrade trade;              // Instancia global del objeto CTrade

//+------------------------------------------------------------------+
//| Includes Adicionales (si fueran necesarios en el futuro)        |
//+------------------------------------------------------------------+
// #include <Arrays\ArrayObj.mqh> // Ejemplo si se usan arrays de objetos más complejos

//+------------------------------------------------------------------+
//| Estructuras de Datos del EA                                      |
//+------------------------------------------------------------------+

// Estructura para Puntos de Swing (usada internamente para análisis estructural)
struct SwingPoint
{
   datetime time;   // Tiempo del swing
   double   price;  // Precio del swing
   bool     isHigh; // true si es un swing high, false si es un swing low
};

// Enumerado para el Ámbito de la Liquidez
enum LiquidityScope
{
    LIQUIDITY_SCOPE_UNKNOWN,  // Ámbito desconocido o no aplicable
    LIQUIDITY_SCOPE_INTERNAL, // Liquidez interna a un rango
    LIQUIDITY_SCOPE_EXTERNAL  // Liquidez externa a un rango (ej. PDH/L)
};

// Estructura para Zonas de Liquidez (mejorada)
struct LiquidityZone {
   double   price;        // Precio del nivel de liquidez
   bool     isBuySide;    // true: liquidez de compra (por encima de un high), false: liquidez de venta (por debajo de un low)
   datetime time;         // Tiempo de formación/identificación de la liquidez
   double   strength;     // Puntuación de la fuerza/importancia de la zona (0-10)
   string   type;         // Descripción: "Swing M15", "EQH H1", "PDH", "Session H London", etc.
   LiquidityScope scope;  // Ámbito de la liquidez (Interna o Externa)
   int      touchCount;   // Número de toques (relevante para EQH/EQL)
   bool     isClean;      // Si los niveles son "limpios" (relevante para EQH/EQL "engineered")
   // bool     isSwept;      // Podríamos añadir un flag si esta zona específica ya fue barrida recientemente (requiere lógica adicional)
};

// Estructura para Order Blocks (OB) (mejorada)
struct OrderBlock {
   bool     isBullish;        // true si es un OB alcista (esperamos compras), false si es bajista
   double   openPrice;        // Precio de apertura de la vela del OB
   double   closePrice;       // Precio de cierre de la vela del OB
   double   highPrice;        // Máximo de la vela del OB
   double   lowPrice;         // Mínimo de la vela del OB
   datetime time;             // Tiempo de inicio de la vela del OB
   bool     isSwept;          // true si el OB ha sido mitigado/barrido después de su formación
   double   quality;          // Puntuación de calidad del OB (0-10)
   bool     hasHTFConfluence; // Placeholder: si tiene confluencia con POIs de HTF
   bool     isPremium;        // Placeholder: si está en zona premium (para ventas) o discount (para compras)
   bool     isValid;          // Flag general de validez (cumple criterios básicos)
   double   relativeSize;     // Tamaño del OB relativo al ATR
   // double   volumeRatio;      // Ratio de volumen (si se usa explícitamente, o integrado en 'quality')
};

// Estructura para Fair Value Gaps (FVG)
struct FairValueGap {
   double   startPrice;     // Precio de inicio del FVG
   double   endPrice;       // Precio de fin del FVG
   bool     isBullish;      // true si es un FVG alcista (vacío hacia arriba), false si es bajista
   datetime timeFirstCandle; // Tiempo de la primera vela que forma el FVG
   datetime timeThirdCandle; // Tiempo de la tercera vela que forma el FVG
   bool     isFilled;       // Si el FVG ha sido completamente llenado
   bool     isPartiallyFilled; // Si el FVG ha sido parcialmente llenado (ej. 50%)
};

// Estructura para Breaker Blocks (BB) (mejorada)
struct BreakerBlock {
   double   price;            // Precio del breaker (el H/L del OB fallido que se rompió)
   bool     isBullish;        // Dirección del Breaker (opuesta al OB fallido)
   datetime confirmationTime; // Tiempo del CAMBIO ESTRUCTURAL (ChoCH/BOS) que confirma el breaker
   double   qualityScore;     // Puntuación de calidad del Breaker Block
   datetime originalOBTime;   // Tiempo del OB original que falló y formó este breaker
   bool     isMitigated;      // Si el Breaker Block ya ha sido tocado/mitigado
};

// Enumerado para el Contexto de la Narrativa de Precios (ICT Model 2022)
enum PriceNarrativeContext
{
    NARRATIVE_UNKNOWN,                    // Contexto no determinado
    NARRATIVE_SEEKING_LIQUIDITY,          // Precio buscando liquidez
    NARRATIVE_REPRICING_AFTER_SWEEP,      // Precio en re-pricing después de un barrido de liquidez importante
    NARRATIVE_REPRICING_AFTER_HTF_FVG_FILL // Precio en re-pricing después de llenar un FVG de HTF
};

// Enumerado para el Estado de la Estructura de Mercado
enum MarketStructureState
{
   MSS_BULLISH, // Tendencia alcista (HH y HL)
   MSS_BEARISH, // Tendencia bajista (LH y LL)
   MSS_RANGE,   // En rango o sin estructura clara
   MSS_UNKNOWN  // Estructura no determinada
};

// Enumerado para el Régimen de Mercado (Volatilidad)
enum MarketRegime
{
    HIGH_VOLATILITY, // Alta volatilidad
    LOW_VOLATILITY,  // Baja volatilidad
    RANGE_MARKET     // Mercado en rango (puede solaparse con baja volatilidad)
};

// Enumerado para el Modo de Entrada en FVG (para confirmación M2022 y Silver Bullet)
enum FVGEntryPriceMode
{
    FVG_ENTRY_START, // Inicio del FVG (más agresivo para la dirección del FVG)
    FVG_ENTRY_MID,   // 50% del FVG
    FVG_ENTRY_END    // Fin del FVG (más conservador para la dirección del FVG, más profundo)
};

// Enumerado para el Modo de Entrada en Order Block
enum OBEntryTypeMode // Renombrado para evitar conflicto con FVGEntryPriceMode
{
    OB_ENTRY_OPEN,       // Entrada en la apertura de la vela del OB
    OB_ENTRY_BODY_50,    // Entrada en el 50% del cuerpo de la vela del OB
    OB_ENTRY_WICK_EXTREME // Entrada en el extremo de la mecha (High para OB alcista, Low para OB bajista)
                         // Esto es diferente al original; el original usaba High/Low de la vela
                         // Para un OB Bullish (vela bajista), entrada en su High es más agresiva, Open más conservadora.
                         // Corregiremos la lógica de entrada para ser más precisa.
                         // ICT suele referirse al Open del OB o al Mean Threshold (50% del OB).
};


// Estructura para Proyecciones de Desviación Estándar
struct StandardDeviationProjections
{
    double   mean;              // Media del rango de precios
    double   stdDev;            // Desviación estándar del rango de precios
    double   projPlus1;         // Media +1 DE
    double   projPlus2;         // Media +2 DE
    double   projPlus2_5;       // Media +2.5 DE
    double   projPlus4;         // Media +4 DE
    double   projMinus1;        // Media -1 DE
    double   projMinus2;        // Media -2 DE
    double   projMinus2_5;      // Media -2.5 DE
    double   projMinus4;        // Media -4 DE
    datetime calculationTime;   // Momento del último cálculo
    datetime rangeStartTimeUsed; // Inicio del rango de datos usado
    datetime rangeEndTimeUsed;   // Fin del rango de datos usado
    ENUM_TIMEFRAMES rangeTimeframeUsed; // TF de los datos usados
};


//+------------------------------------------------------------------+
//| Inputs del EA Agrupados                                          |
//+------------------------------------------------------------------+

// --- Configuración General de Trading ---
input group "--- Configuración General de Trading ---";
input double LotSize                  = 0.01; // Lote base para las operaciones (ajustar según gestión de riesgo)
input int    MaxTradesPerDay          = 2;    // Máximo de trades permitidos por día
input int    StopLossPips             = 15;   // Stop Loss inicial en pips (usado si no hay SL dinámico o de estructura)
input int    EntryTolerancePips       = 2;    // Tolerancia en pips para la entrada respecto al POI
input double RiskRewardRatio          = 2.5;  // Ratio Riesgo:Beneficio para el TP inicial (si no hay TP por liquidez)
input int    MagicNumberEA            = 13579; // Número mágico para las órdenes del EA
string       InpEAName                = "LiquidityICT2022"; // Nombre del EA para comentarios en trades

// --- Gestión de Riesgo y Stops ---
input group "--- Gestión de Riesgo y Stops ---";
input bool   UseBreakEven             = true;  // Activar/Desactivar Break Even
input int    BreakEvenPips            = 20;    // Pips en positivo para mover SL a Break Even (+1 pip)
input bool   UseTrailingStop          = false; // Activar/Desactivar Trailing Stop estándar (ignorado si Fractal está activo)
input int    TrailingDistancePips     = 15;    // Distancia en pips para el Trailing Stop estándar
input bool   UsePartialClose          = true;  // Activar/Desactivar lógica de cierres parciales
input double PartialClose1_RR         = 1.5;   // R:R para el primer cierre parcial (ej. 1.5R)
input double PartialClose1_Percent    = 30.0;  // Porcentaje del volumen inicial a cerrar en el primer parcial
input double PartialClose2_RR         = 2.5;   // R:R para el segundo cierre parcial (ej. 2.5R)
input double PartialClose2_Percent    = 30.0;  // Porcentaje del volumen inicial a cerrar en el segundo parcial
input bool   UseFractalStopHuntTrailing = true; // Activar/Desactivar Trailing Stop basado en Fractales M15
input int    FractalTrailingDepth     = 2;     // Profundidad del fractal para el trailing (2 = fractal de 5 barras)
input int    FractalTrailingSearchBars= 100;   // Barras hacia atrás para buscar el fractal desde la entrada
input double FractalTrailingBufferPips= 3.0;   // Buffer en pips para el SL fractal

// --- Filtros de Sesión y Bias ---
input group "--- Filtros de Sesión y Bias ---";
input bool   FilterBySessions         = true;  // Activar/Desactivar filtro por sesiones de trading
input int    AsiaOpenHour             = 0;     // Hora de Apertura Sesión Asiática (GMT del servidor, ej. 00) (ICT: 20:00-00:00 EST)
input int    AsiaOpenMinute           = 0;
input int    AsiaCloseHour            = 8;     // Hora de Cierre Sesión Asiática (GMT del servidor, ej. 08)
input int    AsiaCloseMinute          = 0;
input int    LondonOpenHour           = 7;     // Hora de Apertura Sesión Londres (GMT del servidor, ej. 07) (ICT: 02:00-05:00 EST)
input int    LondonOpenMinute         = 0;
input int    LondonCloseHour          = 16;    // Hora de Cierre Sesión Londres (GMT del servidor, ej. 16)
input int    LondonCloseMinute        = 0;
input int    NYOpenHour               = 13;    // Hora de Apertura Sesión Nueva York (GMT del servidor, ej. 13) (ICT: 07:00-10:00 EST)
input int    NYOpenMinute             = 0;
input int    NYCloseHour              = 21;    // Hora de Cierre Sesión Nueva York (GMT del servidor, ej. 21)
input int    NYCloseMinute            = 0;
input bool   UseDailyBias             = true;  // Considerar el Bias Diario (D1) para filtrar trades
input bool   UseH4Bias                = true;  // Considerar el Bias H4 (si D1 no es claro o como confirmación)
// UseH1Confirmation fue eliminado, se usa H4 directamente o se deduce.

// --- Parámetros de Estructura de Mercado y ATR ---
input group "--- Parámetros de Estructura de Mercado y ATR ---";
input int    FractalLookback_M15      = 40;    // Lookback para la detección de estructura en M15
input int    ATRPeriod_M15            = 14;    // Período del ATR en M15 (usado para varios cálculos)
input double ATRBufferFactor          = 1.0;   // Factor para buffers basados en ATR (ej: SL de OB = Low - ATR * Factor)
// ATR_MA_Period, ATR_Volatility_Multiplier fueron eliminados para simplificar,
// se puede usar un ATR directo o el factor de buffer.

// --- Parámetros de Order Blocks (OB) y Breakers (BB) ---
input group "--- Parámetros de Order Blocks (OB) y Breakers (BB) ---";
input ENUM_TIMEFRAMES inpOB_DetectionTF = PERIOD_M5; // Timeframe para detectar OBs y BBs
input double inpOB_MinRangePips         = 1.5;   // Rango mínimo en pips para considerar un Order Block válido en su TF
input OBEntryTypeMode inpOB_EntryMode   = OB_ENTRY_BODY_50; // Modo de entrada en Order Block
input double inpMinOBQualityForEntry    = 6.5;   // Calidad mínima para considerar un OB para entrada
input double inpMinBBQualityForEntry    = 6.8;   // Calidad mínima para un BB (si se usa score explícito)
input int    inpOB_DisplacementBars     = 3;     // Barras a analizar para el desplazamiento del OB
input double inpOB_StrongDisplacementATRRatio = 1.5; // Ratio ATR para considerar un desplazamiento fuerte en 1 barra

// --- Parámetros de Detección de Liquidez (Optimizado) ---
input group "--- Parámetros de Detección de Liquidez (Optimizado) ---";
input int    inpLiq_SwingLookback     = 20;    // Lookback en barras para identificar Swing Points (en cada TF de liquidez)
input double inpLiq_EQH_EQL_TolPips   = 1.0;   // Tolerancia en pips para considerar Equal Highs/Lows
input double inpLiq_StrengthExternalMajor = 9.5; // Fuerza para PMH/L, PWH/L
input double inpLiq_StrengthExternalDaily = 9.0; // Fuerza para PDH/L
input double inpLiq_StrengthExternalSession=8.5; // Fuerza para Session H/L
input double inpLiq_StrengthEQH_EQL_Clean = 8.8; // Fuerza para EQH/EQL "limpios" y con múltiples toques
input double inpLiq_StrengthEQH_EQL_Standard=7.8; // Fuerza para EQH/EQL estándar
input double inpLiq_StrengthSwingInternalBase=6.0; // Fuerza base para swings internos
input int    inpLiq_MinTouchesEQH_EQL_Clean=3;   // Mínimo de toques para considerar EQH/EQL como "clean engineered"
input double inpLiq_EQHCandleBodyMaxPercent=30.0;// Porcentaje máximo del cuerpo de la vela para EQH/L "limpios"

// --- Parámetros de Caza de Liquidez (Stop Hunt) ---
input group "--- Parámetros de Caza de Liquidez (Stop Hunt) ---";
input double inpSH_StopHuntBufferPips   = 2.0;   // Buffer para ajustar SL inicial si está cerca de un nivel de liquidez cazado
input double inpSH_ATR_MinPenetration = 0.3;   // Factor ATR para la *mínima* penetración requerida en un Stop Hunt
input double inpSH_ATR_MaxPenetration = 2.0;   // Factor ATR para la *máxima* penetración permitida en un Stop Hunt
input int    inpSH_MinReversalBars    = 1;     // Número base de barras de confirmación para la reversión post-hunt (en M5)
input double inpSH_ReversalStrengthPercent = 60.0; // Porcentaje mínimo de reversión sobre la penetración para confirmar
input double inpSH_VolumeDivergenceMultiplier = 1.3; // Multiplicador para detectar divergencia de volumen en reversión
input int    inpMinHuntStrengthForNarrative = 7; // Fuerza mínima del hunt para contexto de narrativa
input int    inpMinHuntStrengthForEntry     = 6; // Fuerza mínima del hunt para una entrada directa por Stop Hunt

// --- Parámetros de Fair Value Gap (FVG) ---
input group "--- Parámetros de Fair Value Gap (FVG) ---";
input ENUM_TIMEFRAMES inpFVG_DetectionTF    = PERIOD_M5; // Timeframe principal para detectar FVGs para POIs o entradas directas
// FVGEntryMode para M2022 y SilverBullet tienen sus propios inputs.

// --- Narrativa de Precios (ICT Model 2022) ---
input group "--- Narrativa de Precios (ICT Model 2022) ---";
input ENUM_TIMEFRAMES inpNarrative_HTF        = PERIOD_H1; // Timeframe para FVG y Sweeps de narrativa
input int    inpNarrative_LookbackBarsHTF   = 50;    // Barras en HTF para buscar FVG/Sweeps
input double inpNarrative_MinFVGSizePipsHTF = 8.0;    // Tamaño mínimo del FVG en HTF en pips para narrativa
input int    inpNarrative_RepricingDurationBarsM5 = 10; // Cuántas barras M5 considerar "re-pricing" después de un evento narrativo

// --- Proyecciones de Desviación Estándar ---
input group "--- Proyecciones de Desviación Estándar ---";
input bool   inpEnableStdDevProjections    = true;      // Activar/Desactivar uso de proyecciones de DE
input int    inpStdDev_ProjectionPeriod    = 20;        // Período (velas) para el cálculo de la DE
input ENUM_TIMEFRAMES inpStdDev_RangeDataTF = PERIOD_D1; // Timeframe para obtener los datos del rango de DE
input double inpStdDev_ProjectionTolerancePips = 3.0;   // Tolerancia en pips para alinear POI con proyección
input double inpStdDev_ProjectionQualityBonus = 1.0;    // Bonus de calidad si el POI se alinea con una proyección
input int    inpStdDev_RecalculateMinutes  = 240;     // Recalcular proyecciones cada X minutos (ej. 4 horas)

// --- Confirmación de Entrada (ICT Model 2022) ---
input group "--- Confirmación de Entrada (ICT Model 2022) ---";
input bool   inpEnableEntryConfirmationM2022 = true;      // Activar/Desactivar confirmación Modelo 2022
input ENUM_TIMEFRAMES inpM2022_ConfirmationTF = PERIOD_M1; // Timeframe para buscar BOS/ChoCH y FVG de confirmación
input int    inpM2022_TimeoutBarsM5       = 5;         // Timeout en velas M5 para esperar la confirmación (del TF del POI)
input int    inpM2022_LookbackLTF         = 20;        // Lookback en LTF para BOS/ChoCH/FVG
input FVGEntryPriceMode inpM2022_FVGEntryMode= FVG_ENTRY_MID; // Cómo entrar en el FVG de confirmación
input double inpM2022_ConfirmFVGMinPips   = 0.5;       // Tamaño mínimo en pips del FVG de confirmación en LTF
input bool   inpM2022_UseOriginalPOISL    = true;      // true: SL detrás del POI original. false: SL detrás del swing LTF
input double inpM2022_ConfirmSLBufferPips = 1.5;       // Buffer adicional para el SL de la entrada M2022

// --- Gestión Avanzada de Trades (Invalidación y TP Dinámico) ---
input group "--- Gestión Avanzada de Trades ---";
input bool   inpEnableEarlyInvalidation   = true;      // Activar/Desactivar invalidación temprana de trades
input ENUM_TIMEFRAMES inpInvalidation_TF   = PERIOD_M15;// Timeframe para detectar ChoCH/cambio estructural de invalidación
input int    inpInvalidation_Lookback   = 25;        // Lookback para DetectChoCH en el TF de invalidación
input bool   inpResetFlagsOnEarlyClose  = true;      // Resetear flags (parciales, volumen) en cierre temprano
input bool   UseKeyLevelsForSLTP        = true;      // Usar niveles clave (liquidez) para ajustar TP (OpenTradeSimple)
input double KeyLevelTP_MarginPips      = 3.0;       // Margen en pips para TP cerca de niveles clave
input double inpMinLiqStrengthForTP     = 8.0;       // Fuerza mínima de la zona de liquidez para ser considerada como TP
input double inpMinDistToLiqTP_Pips     = 10.0;      // Distancia mínima en pips desde entryPrice al TP de liquidez
input double inpMaxDistToLiqTP_RR       = 8.0;       // Distancia máxima en R:R al TP de liquidez (basado en SL inicial)

// --- Ponderación de Killzones (ICT) ---
input group "--- Ponderación de Killzones (ICT) ---";
input bool   inpEnableKillzonePonderation = true;     // Activar ponderación para setups en horas clave de KZ
input int    inpKz_GoldenHourMinutes      = 90;        // Minutos iniciales de London/NY KZ para ponderación
input double inpKz_GoldenHourQualityBonus = 0.75;      // Bonus de calidad para setups en estas "golden hours"

// --- NY Silver Bullet (ICT) ---
input group "--- NY Silver Bullet (ICT) ---";
input bool   inpEnableNYSilverBullet      = true;      // Activar/Desactivar lógica del Silver Bullet
input int    inpNYSB_StartHour            = 10;        // Hora de inicio del Silver Bullet (Servidor) - Default 10 AM (NY Time)
input int    inpNYSB_StartMinute          = 0;
input int    inpNYSB_EndHour              = 11;        // Hora de fin del Silver Bullet (Servidor) - Default 11 AM (NY Time)
input int    inpNYSB_EndMinute            = 0;
input ENUM_TIMEFRAMES inpNYSB_FVG_TF       = PERIOD_M1; // Timeframe para buscar FVG (M1 o M5)
input double inpNYSB_FVG_MinSizePips    = 0.3;       // Tamaño mínimo del FVG en pips para Silver Bullet
input int    inpNYSB_LiqLookbackBarsM5  = 30;        // Barras M5 hacia atrás para buscar el barrido de sesión H/L
input double inpNYSB_HuntStrengthMin    = 5.0;       // Fuerza mínima del Stop Hunt de la liquidez de sesión
input FVGEntryPriceMode inpNYSB_FVGEntryMode = FVG_ENTRY_MID; // Cómo entrar en el FVG del Silver Bullet
input double inpNYSB_SL_Pips            = 7.0;       // SL fijo en pips para trades Silver Bullet
input double inpNYSB_TP_RR              = 2.5;       // R:R para TP de trades Silver Bullet
input bool   inpNYSB_TradeOncePerSession  = true;      // Solo tomar un trade Silver Bullet por ventana horaria SB

//+------------------------------------------------------------------+
//| Variables Globales del EA                                        |
//+------------------------------------------------------------------+

// Arrays para almacenar elementos ICT detectados
LiquidityZone    liquidityZones[]; // Array principal para TODAS las zonas de liquidez
OrderBlock       orderBlocks[];    // Array para Order Blocks detectados
FairValueGap     fairValueGaps[];  // Array para Fair Value Gaps detectados (principalmente en inpFVG_DetectionTF)
BreakerBlock     breakerBlocks[];  // Array para Breaker Blocks detectados

// Variables de Bias y Estructura de Mercado
bool g_D1BiasIsBullish = false; // Bias Diario (D1)
bool g_H4BiasIsBullish = false; // Bias de H4
MarketStructureState g_m15Structure = MSS_UNKNOWN; // Estructura de mercado en M15
MarketStructureState g_h1Structure  = MSS_UNKNOWN; // Estructura de mercado en H1 (si se usa para confluencia)

// Variables para Control de Trades y Frecuencia
int      g_tradesToday = 0;          // Contador de trades en el día actual
datetime g_lastTradeTimeThisSessionH4 = 0; // Para no operar demasiado seguido en la misma vela H4
datetime g_lastFullUpdateTime = 0;       // Para controlar frecuencia de cálculos pesados
int      g_updateFrequencySeconds = 10;  // Actualizar detecciones principales cada X segundos (ej. 10-15s)

// Variables para la Narrativa de Precios
PriceNarrativeContext g_priceNarrative = NARRATIVE_UNKNOWN;
datetime g_lastSignificantSweepTime_Narrative = 0;
double   g_lastSignificantSweepLevel_Narrative = 0;
bool     g_lastSignificantSweepWasBuySide_Narrative = false;
datetime g_lastHTFFVGFillTime_Narrative = 0;
double   g_lastHTFFVGFillLevelStart_Narrative = 0;
double   g_lastHTFFVGFillLevelEnd_Narrative = 0;
bool     g_lastHTFFVGFillWasBullish_Narrative = false;

// Variables para Proyecciones de Desviación Estándar
StandardDeviationProjections g_stdDevProjections;

// Variables para la Confirmación de Entrada Modelo 2022
bool       g_waitingForEntryConfirmation = false;
OrderBlock g_confirmedPOI_M2022;         // El POI (ej. M5) que fue tocado y espera confirmación LTF
datetime   g_poiTouchTime_M2022 = 0;     // Tiempo en que el POI fue tocado (vela M5)
bool       g_entryDirection_M2022 = false; // Dirección de entrada esperada para la confirmación

// Variables para Killzones y Silver Bullet
bool     g_isInGoldenKillzoneHour = false;   // Si la hora actual está en la "golden hour" de London/NY
bool     g_isInNYSilverBulletWindow = false; // Si la hora actual está en la ventana del Silver Bullet
datetime g_lastNYSilverBulletTradeTime = 0;  // Tiempo del último trade Silver Bullet
int      g_NYSilverBulletTradesToday = 0;    // Contador de trades SB hoy (o por sesión SB)

// Variables para Máximos/Mínimos de Sesiones (ejemplos, deben actualizarse correctamente)
// Estos se usan en UpdateSessionHighsLows y FindSweptSessionLiquidity
double   g_AsiaHigh = 0, g_AsiaLow = 0;
datetime g_AsiaOpenTimeActual = 0, g_AsiaCloseTimeActual = 0; // Tiempos reales de la sesión actual de Asia
double   g_LondonHigh = 0, g_LondonLow = 0;
datetime g_LondonOpenTimeActual = 0, g_LondonCloseTimeActual = 0;
double   g_NYHigh = 0, g_NYLow = 0;
datetime g_NYOpenTimeActual = 0, g_NYCloseTimeActual = 0;
bool     g_AsiaSessionProcessed = false; // Para saber si ya se calcularon H/L de la sesión actual
bool     g_LondonSessionProcessed = false;
bool     g_NYSessionProcessed = false;


// Variables para gestión de riesgo dinámica (si se reimplementa desde el original)
// double dyn_ATRMultiplierForMinPenetration; // Reemplazado por inpSH_ATR_MinPenetration
// double dyn_ATRMultiplierForMaxPenetration; // Reemplazado por inpSH_ATR_MaxPenetration
// int    dyn_BreakEvenPips;                // Reemplazado por BreakEvenPips (input directo)
// int    dyn_TrailingDistancePips;         // Reemplazado por TrailingDistancePips (input directo)
MarketRegime g_currentMarketRegime = RANGE_MARKET; // Régimen de volatilidad actual

// Variables para Almacenamiento de Volumen Inicial y Flags de Parciales
static ulong  g_positionTickets[]; // Almacena los tickets de las posiciones activas
static double g_initialVolumes[];  // Almacena el volumen inicial correspondiente a cada ticket
static int    g_partialClosedFlags[100]; // Flags para etapas de cierre parcial (tamaño fijo, podría ser dinámico)

// Constantes para indicadores si es necesario (ej. handles)
// static int      s_atrHandle_M15 = INVALID_HANDLE; // Ejemplo si se usan handles estáticos

//+------------------------------------------------------------------+
//| Declaraciones Adelantadas de Funciones (Prototipos)              |
//+------------------------------------------------------------------+

// --- Funciones de Inicialización y Deinicialización ---
void InitializeGlobalVariables();
void CalculateSessionTimesToday(datetime currentTime,
                                int openHour, int openMinute, int closeHour, int closeMinute,
                                datetime &outSessionOpenTime, datetime &outSessionCloseTime);
void UpdateActualSessionHighsLows(datetime currentTime);


// --- Funciones de Indicadores y Cálculos Auxiliares ---
bool   GetADXValues(string symbol, ENUM_TIMEFRAMES tf, int period, int barShift, double &adxVal, double &plusDiVal, double &minusDiVal);
double GetEMAValue(string symbol, ENUM_TIMEFRAMES tf, int periodEMA, int barShift=0);
double ComputeATR(ENUM_TIMEFRAMES tf, int period, int shift = 0);
// MarketRegime DetermineMarketRegime(double volatilityIndex, double highThreshold, double lowThreshold); // Si se usa índice complejo
// void AdjustParametersBasedOnVolatility(MarketRegime regime); // Si se usa ajuste dinámico complejo
double CalculateLotSize(double stopLossValue); // Modificado para tomar el SL real
bool   IsVolumeTrendingUp(ENUM_TIMEFRAMES tf, int barIndex, int lookback=3, double multiplier=1.0);


// --- Funciones de Detección de Elementos ICT ---
void   DetectLiquidity(); // Función principal de liquidez
void   AddLiquidityZone(double price, bool isBuySide, datetime time, double strength, string type, LiquidityScope scope, int touchCount = 1, bool isClean = false, double tolerancePips = 1.0);
void   UpdateOldHighsLows();
void   UpdateSessionHighsLows(); // Lógica para H/L de sesiones en curso y pasadas (si es necesario para barridos)
void   DetectFairValueGaps(ENUM_TIMEFRAMES fvgTF); // Parámetro para TF
FairValueGap FindLastFVG(ENUM_TIMEFRAMES timeframe, int lookbackBars, int barStartSearch, bool fvgDirectionBullish, datetime afterTime, double minSizePips); // Renombrado y mejorado
void   DetectOrderBlocks(ENUM_TIMEFRAMES obTF);
double AssessOBQuality(OrderBlock &ob, ENUM_TIMEFRAMES obTF); // OB y su TF
bool   IsOBSwept(const OrderBlock &ob, ENUM_TIMEFRAMES obTF);
void   SortOrderBlocksByQuality();
void   DetectBreakerBlocks(ENUM_TIMEFRAMES bbTF, ENUM_TIMEFRAMES obSourceTF);
bool   CheckIfPriceTookSignificantLiquidity(double failedSwingPrice, bool isSweepOfHigh, double &outLiquidityStrength);
bool   DetectStopHunt(double level, bool isBuySideLiquidity, datetime &outHuntTime, double &outPenetrationPrice, int &outHuntStrength, ENUM_TIMEFRAMES timeframe = PERIOD_M5); // Mejorado para devolver más info


// --- Funciones de Estructura de Mercado y Bias ---
void   ComputeD1Bias();
void   ComputeH4Bias();
MarketStructureState DetectMarketStructure(ENUM_TIMEFRAMES tf, int lookbackBars, int pivotStrength = 2);
bool   DetectBOS(ENUM_TIMEFRAMES tf, int barIndexShift, bool isBullishAttempt, int lookbackSwings = 15, int pivotStrength = 2);
bool   DetectChoCH(ENUM_TIMEFRAMES tf, int barIndexShift, bool isBullishAttempt, int lookbackSwings = 15, int pivotStrength = 2);


// --- Funciones de Lógica de Entrada ---
void   CheckTradeEntries();
void   CheckSilverBulletSetup();
bool   IsNYSilverBulletWindowActive(datetime currentTime);
bool   FindSweptSessionLiquidity(int lookbackM5, double minHuntStrength, datetime &outSweepTime, double &outSweptLevel, bool &outWasBuysideSweep, string &outSweptSessionName);
void   CheckEntryConfirmationM2022();


// --- Funciones de Gestión de Órdenes y Riesgo ---
bool   OpenTrade(bool isLong, double lot, double entryPrice, double stopLoss, double takeProfit, string comment); // Renombrado desde OpenTradeSimple
void   ManageRisk();
void   ManagePartialClosures(ulong ticket); // Separado de ManageRisk para claridad
void   ApplyTrailingStops(ulong ticket); // Separado de ManageRisk
void   ApplyFractalTrailing(ulong ticket, int fractalDepth, double bufferPips, int searchBarsAfterEntry);
void   ApplyStandardTrailing(ulong ticket, double trailingDistancePips);
// void   AdvancedAdaptiveTrailing(ulong ticket, double fixedTakeProfit); // Puede integrarse en ApplyTrailingStops
bool   IsStopLossNearLiquidity(double proposedSL, bool isTradeLong, double proximityRangePips, string &outLiqType);
LiquidityZone FindNextRelevantLiquidityTarget(bool isLong, double entryPrice, double initialStopLoss);


// --- Funciones de Narrativa de Precios y Desviación Estándar ---
void   UpdatePriceNarrativeContext();
bool   CheckIfSignificantLiquidityWasSwept(ENUM_TIMEFRAMES checkTF, int lookback, int minHuntStrength, datetime &outSweepTime, double &outSweepLevel, bool &outWasBuySide);
bool   CheckIfHTFFVGFilled(ENUM_TIMEFRAMES checkTF, int lookback, double minFVGSizePips, datetime &outFillTime, double &outFVGStart, double &outFVGEnd, bool &outWasBullishFVG);
OrderBlock FindOBOriginatingSweep(datetime sweepTime, double sweepLevel, bool wasBuysideSweep, ENUM_TIMEFRAMES obTF);
OrderBlock FindOBAlignedWithHTFFVG(datetime fvgFillTime, bool fvgWasBullishHTF, ENUM_TIMEFRAMES obTF);
void   UpdateAndStoreStdDevProjections(bool forceRecalculate = false);
bool   CalculateStandardDeviationProjections(datetime rangeStart, datetime rangeEnd, ENUM_TIMEFRAMES dataTF, int candlesForCalc,
                                           double &outMean, double &outStdDev,
                                           double &outP1, double &outP2, double &outP2_5, double &outP4,
                                           double &outM1, double &outM2, double &outM2_5, double &outM4);

// --- Funciones Auxiliares para Gestión de Volumen y Flags ---
int    FindTicketIndex(ulong ticket);
void   StoreInitialVolume(ulong ticket, double volume);
double GetStoredInitialVolume(ulong ticket);
void   RemoveStoredVolume(ulong ticket);

// --- Funciones de Debug y Visualización (Opcional) ---
// void   DrawLiquidityZoneOnChart(const LiquidityZone &lz);
// void   DrawOrderBlockOnChart(const OrderBlock &ob);
// void   RemoveChartObjectsByType(string typePrefix);

//+------------------------------------------------------------------+
//| OnInit - Función de Inicialización del EA                        |
//+------------------------------------------------------------------+
int OnInit()
{
   Print("+------------------------------------------------------------------+");
   PrintFormat("| %s - Versión %s Inicializado." );
   Print("| EA Basado en Conceptos Avanzados de ICT 2022.                    |");
   Print("| Hora del Servidor Actual: ", TimeToString(TimeCurrent(), TIME_SECONDS));
   PrintFormat("| Zona Horaria del Servidor (respecto a GMT): %.1f horas.", TimeGMTOffset() / 3600.0);
   PrintFormat("| Número Mágico del EA: %d", MagicNumberEA);
   Print("+------------------------------------------------------------------+");

   Print("--- Validación de Inputs Críticos (Advertencias si están fuera de rango) ---");
   if(inpMinOBQualityForEntry < 0 || inpMinOBQualityForEntry > 10) {
      Print("OnInit Advertencia: inpMinOBQualityForEntry (", inpMinOBQualityForEntry, ") está fuera del rango recomendado (0-10).");
   }
   if(inpStdDev_ProjectionPeriod <= 1) {
       Print("OnInit Advertencia: inpStdDev_ProjectionPeriod (", inpStdDev_ProjectionPeriod, ") es <= 1. Recomendado > 1 (ej. 20).");
   }
   if(MaxTradesPerDay <=0) { // Este input es del código original
       Print("OnInit Advertencia: MaxTradesPerDay (", MaxTradesPerDay, ") es <= 0. No se abrirán trades.");
   }
   if(inpNYSB_StartHour < 0 || inpNYSB_StartHour > 23 || inpNYSB_EndHour < 0 || inpNYSB_EndHour > 23 ||
      inpNYSB_StartMinute < 0 || inpNYSB_StartMinute > 59 || inpNYSB_EndMinute < 0 || inpNYSB_EndMinute > 59) {
       Print("OnInit Advertencia: Horas/Minutos del Silver Bullet inválidos. Revisa la configuración.");
   }
   if(StopLossPips <=0 && inpNYSB_SL_Pips <=0 && !UseKeyLevelsForSLTP) { // Si no hay forma de definir SL
        Print("OnInit Advertencia: No hay un StopLossPips definido por defecto y el SL del SilverBullet es <=0. Revisa la configuración de SL.");
   }
   if(RiskRewardRatio <=0 && inpNYSB_TP_RR <=0 && !UseKeyLevelsForSLTP) {
        Print("OnInit Advertencia: No hay un RiskRewardRatio definido y el TP R:R del SilverBullet es <=0. Revisa la configuración de TP.");
   }


   InitializeGlobalVariables(); // Inicializa todas las variables globales y arrays

   // Forzar primer cálculo de algunos elementos clave al iniciar el EA
   if(UseDailyBias) ComputeD1Bias();
   if(UseH4Bias || UseDailyBias) ComputeH4Bias(); // H4 se usa más, actualizar

   g_m15Structure = DetectMarketStructure(PERIOD_M15, FractalLookback_M15);
   g_h1Structure  = DetectMarketStructure(PERIOD_H1, FractalLookback_M15 * 2);

   DetectLiquidity(); // Esto llama a UpdateOldHighsLows y UpdateSessionHighsLows
   DetectFairValueGaps(inpFVG_DetectionTF);
   DetectOrderBlocks(inpOB_DetectionTF);
   DetectBreakerBlocks(inpOB_DetectionTF, inpOB_DetectionTF);

   UpdatePriceNarrativeContext();      // Actualiza el contexto de la narrativa de precios
   UpdateAndStoreStdDevProjections(true); // Forzar cálculo de DE al inicio

   Print("OnInit: Inicialización completada. EA listo para operar.");
   return(INIT_SUCCEEDED);
}


//+------------------------------------------------------------------+
//| InitializeGlobalVariables - Inicializa variables globales        |
//+------------------------------------------------------------------+
void InitializeGlobalVariables()
{
   // Arrays
   ArrayResize(liquidityZones,0);
   ArrayResize(orderBlocks,0);
   ArrayResize(fairValueGaps,0);
   ArrayResize(breakerBlocks,0);
   ArrayResize(g_positionTickets,0);
   ArrayResize(g_initialVolumes,0);
   ArrayInitialize(g_partialClosedFlags,0);

   // Contadores y Tiempos
   g_tradesToday = 0;
   g_lastTradeTimeThisSessionH4 = 0;
   g_lastFullUpdateTime = 0;
   g_priceNarrative = NARRATIVE_UNKNOWN;
   g_lastSignificantSweepTime_Narrative = 0;
   g_lastHTFFVGFillTime_Narrative = 0;
   g_stdDevProjections.calculationTime = 0; // Para forzar primer cálculo
   g_waitingForEntryConfirmation = false;
   g_poiTouchTime_M2022 = 0;
   g_isInGoldenKillzoneHour = false;
   g_isInNYSilverBulletWindow = false;
   g_lastNYSilverBulletTradeTime = 0;
   g_NYSilverBulletTradesToday = 0;

   // Variables de Sesión (resetear H/L calculados)
   g_AsiaHigh = 0; g_AsiaLow = 0; g_AsiaOpenTimeActual = 0; g_AsiaCloseTimeActual = 0; g_AsiaSessionProcessed = false;
   g_LondonHigh = 0; g_LondonLow = 0; g_LondonOpenTimeActual = 0; g_LondonCloseTimeActual = 0; g_LondonSessionProcessed = false;
   g_NYHigh = 0; g_NYLow = 0; g_NYOpenTimeActual = 0; g_NYCloseTimeActual = 0; g_NYSessionProcessed = false;

   // Establecer nombre del EA para la clase CTrade
   trade.SetExpertMagicNumber(MagicNumberEA);
   trade.SetMarginMode(); // Usa el modo de margen de la cuenta
   trade.SetTypeFillingBySymbol(Symbol()); // Usa el tipo de ejecución por defecto del símbolo
   // trade.LogLevel(LOG_LEVEL_ERROR); // Configurar nivel de log para CTrade (opcional)

   Print("InitializeGlobalVariables: Variables globales inicializadas.");
}


//+------------------------------------------------------------------+
//| OnDeinit - Función de Deinicialización del EA                    |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
{
   PrintFormat("%s: Deinicializado. Razón: %d.", InpEAName, reason);
   // Limpieza de objetos gráficos si se usaron (ej. RemoveChartObjectsByType)
   // ArrayFree(liquidityZones); // No necesario para arrays dinámicos de structs simples, se liberan solos.
   // ArrayFree(orderBlocks);
   // ...
   // Reset handles si se usaron estáticos
   // if(s_atrHandle_M15 != INVALID_HANDLE) IndicatorRelease(s_atrHandle_M15);

   Print("OnDeinit: Limpieza completada.");
}


//+------------------------------------------------------------------+
//| CalculateSessionTimesToday                                       |
//| Calcula los datetime de inicio y fin para una sesión DADA HOY    |
//| basado en las horas y minutos de input y el día actual.          |
//+------------------------------------------------------------------+
void CalculateSessionTimesToday(datetime currentTime,
                                int openHour, int openMinute, int closeHour, int closeMinute,
                                datetime &outSessionOpenTime, datetime &outSessionCloseTime)
{
    MqlDateTime currentStruct, openStruct, closeStruct;
    TimeToStruct(currentTime, currentStruct); // Día de referencia

    // Tiempo de Apertura para Hoy
    openStruct.year = currentStruct.year;
    openStruct.mon  = currentStruct.mon;
    openStruct.day  = currentStruct.day;
    openStruct.hour = openHour;
    openStruct.min  = openMinute;
    openStruct.sec  = 0;
    outSessionOpenTime = StructToTime(openStruct);

    // Tiempo de Cierre
    closeStruct.year = currentStruct.year;
    closeStruct.mon  = currentStruct.mon;
    closeStruct.day  = currentStruct.day; // Inicialmente mismo día
    closeStruct.hour = closeHour;
    closeStruct.min  = closeMinute;
    closeStruct.sec  = 0;

    if (closeHour < openHour || (closeHour == openHour && closeMinute <= openMinute))
    {
        // La sesión cruza la medianoche, así que el cierre es el día SIGUIENTE
        datetime tempCloseTime = StructToTime(closeStruct);
        tempCloseTime += 24 * 60 * 60; // Añadir un día
        outSessionCloseTime = tempCloseTime;
    }
    else
    {
        outSessionCloseTime = StructToTime(closeStruct);
    }
}

//+------------------------------------------------------------------+
//| UpdateActualSessionHighsLows                                     |
//| Actualiza los H/L GLOBALES (g_AsiaHigh, etc.) para las sesiones  |
//| de Asia, Londres y NY para la sesión EN CURSO o la más RECIENTE  |
//| CONCLUIDA del día de trading del EA.                             |
//| Esta función es llamada en OnTick.                               |
//+------------------------------------------------------------------+
void UpdateActualSessionHighsLows(datetime currentTime)
{
    // Calcular tiempos de sesión para HOY según los inputs y el día actual
    datetime asiaOpenToday, asiaCloseToday;
    datetime londonOpenToday, londonCloseToday;
    datetime nyOpenToday, nyCloseToday;

    CalculateSessionTimesToday(currentTime, AsiaOpenHour, AsiaOpenMinute, AsiaCloseHour, AsiaCloseMinute, asiaOpenToday, asiaCloseToday);
    CalculateSessionTimesToday(currentTime, LondonOpenHour, LondonOpenMinute, LondonCloseHour, LondonCloseMinute, londonOpenToday, londonCloseToday);
    CalculateSessionTimesToday(currentTime, NYOpenHour, NYOpenMinute, NYCloseHour, NYCloseMinute, nyOpenToday, nyCloseToday);

    MqlRates ratesForHighLow[1]; // Array para obtener la vela inicial de la sesión
    ENUM_TIMEFRAMES detailTF = PERIOD_M1; // Timeframe para buscar H/L intra-sesión

    // --- Lógica para Sesión Asiática ---
    if (currentTime >= asiaOpenToday && currentTime < asiaCloseToday) // Dentro de la sesión de Asia actual
    {
        if (!g_AsiaSessionProcessed) { // Si no se ha procesado hoy o es la primera vez que entramos en esta sesión
            g_AsiaOpenTimeActual = asiaOpenToday;
            g_AsiaCloseTimeActual = asiaCloseToday; // Tiempo de cierre programado
            // Resetear H/L al inicio de la sesión (o si es la primera vez que se detecta esta sesión hoy)
            datetime firstBarTime = iTime(Symbol(), detailTF, iBarShift(Symbol(), detailTF, asiaOpenToday, true));
            if (g_AsiaHigh == 0 || g_AsiaOpenTimeActual != asiaOpenToday) { // Primera vez hoy para esta sesión
                if(CopyRates(Symbol(), detailTF, firstBarTime, 1, ratesForHighLow) > 0) {
                    g_AsiaHigh = ratesForHighLow[0].high;
                    g_AsiaLow  = ratesForHighLow[0].low;
                } else {
                    g_AsiaHigh = 0; g_AsiaLow = 0; // No se pudieron obtener datos
                }
            }
        }
        g_AsiaSessionProcessed = false; // Marcar como no procesada mientras está activa

        // Actualizar H/L intra-sesión
        int firstBarShift = iBarShift(Symbol(), detailTF, g_AsiaOpenTimeActual, false);
        int currentBarShift = iBarShift(Symbol(), detailTF, currentTime, false);
        if(firstBarShift >=0 && currentBarShift >=0 && firstBarShift >= currentBarShift) {
            int barsInSessionSoFar = firstBarShift - currentBarShift + 1;
            if (barsInSessionSoFar > 0) {
                MqlRates sessionRates[];
                int copied = CopyRates(Symbol(), detailTF, currentBarShift, barsInSessionSoFar, sessionRates);
                if (copied == barsInSessionSoFar && copied > 0) {
                    double sessionH = sessionRates[0].high;
                    double sessionL = sessionRates[0].low;
                    for (int k = 1; k < copied; k++) {
                        if (sessionRates[k].high > sessionH) sessionH = sessionRates[k].high;
                        if (sessionRates[k].low < sessionL) sessionL = sessionRates[k].low;
                    }
                    g_AsiaHigh = sessionH;
                    g_AsiaLow  = sessionL;
                }
            }
        }
    }
    else if (currentTime >= asiaCloseToday && g_AsiaOpenTimeActual == asiaOpenToday && !g_AsiaSessionProcessed) // Asia acaba de cerrar
    {
        g_AsiaSessionProcessed = true; // Marcar como procesada para este ciclo de sesión
        // El H/L ya debería estar finalizado por la lógica de arriba.
        // Se podría añadir a liquidityZones aquí o en UpdateSessionHighsLows (la que llama AddLiquidityZone).
        // PrintFormat("UpdateActualHL: Sesión Asia (Hoy) Cerrada. H:%.5f L:%.5f (Abrió: %s, CerróTeórico: %s)", g_AsiaHigh, g_AsiaLow, TimeToString(g_AsiaOpenTimeActual), TimeToString(asiaCloseToday));
    }


    // --- Lógica para Sesión de Londres ---
    if (currentTime >= londonOpenToday && currentTime < londonCloseToday)
    {
        if (!g_LondonSessionProcessed || g_LondonOpenTimeActual != londonOpenToday) {
            g_LondonOpenTimeActual = londonOpenToday;
            g_LondonCloseTimeActual = londonCloseToday;
            datetime firstBarTime = iTime(Symbol(), detailTF, iBarShift(Symbol(), detailTF, londonOpenToday, true));
            if (g_LondonHigh == 0 || g_LondonOpenTimeActual != londonOpenToday) {
                 if(CopyRates(Symbol(), detailTF, firstBarTime, 1, ratesForHighLow) > 0) {
                    g_LondonHigh = ratesForHighLow[0].high;
                    g_LondonLow  = ratesForHighLow[0].low;
                } else {
                    g_LondonHigh = 0; g_LondonLow = 0;
                }
            }
        }
        g_LondonSessionProcessed = false;

        int firstBarShift = iBarShift(Symbol(), detailTF, g_LondonOpenTimeActual, false);
        int currentBarShift = iBarShift(Symbol(), detailTF, currentTime, false);
        if(firstBarShift >=0 && currentBarShift >=0 && firstBarShift >= currentBarShift) {
            int barsInSessionSoFar = firstBarShift - currentBarShift + 1;
            if (barsInSessionSoFar > 0) {
                MqlRates sessionRates[];
                int copied = CopyRates(Symbol(), detailTF, currentBarShift, barsInSessionSoFar, sessionRates);
                if (copied == barsInSessionSoFar && copied > 0) {
                    double sessionH = sessionRates[0].high;
                    double sessionL = sessionRates[0].low;
                    for (int k = 1; k < copied; k++) {
                        if (sessionRates[k].high > sessionH) sessionH = sessionRates[k].high;
                        if (sessionRates[k].low < sessionL) sessionL = sessionRates[k].low;
                    }
                    g_LondonHigh = sessionH;
                    g_LondonLow  = sessionL;
                }
            }
        }
    }
    else if (currentTime >= londonCloseToday && g_LondonOpenTimeActual == londonOpenToday && !g_LondonSessionProcessed)
    {
        g_LondonSessionProcessed = true;
        // PrintFormat("UpdateActualHL: Sesión Londres (Hoy) Cerrada. H:%.5f L:%.5f (Abrió: %s, CerróTeórico: %s)", g_LondonHigh, g_LondonLow, TimeToString(g_LondonOpenTimeActual), TimeToString(londonCloseToday));
    }

    // --- Lógica para Sesión de Nueva York ---
    if (currentTime >= nyOpenToday && currentTime < nyCloseToday)
    {
        if (!g_NYSessionProcessed || g_NYOpenTimeActual != nyOpenToday) {
            g_NYOpenTimeActual = nyOpenToday;
            g_NYCloseTimeActual = nyCloseToday;
            datetime firstBarTime = iTime(Symbol(), detailTF, iBarShift(Symbol(), detailTF, nyOpenToday, true));
            if(g_NYHigh == 0 || g_NYOpenTimeActual != nyOpenToday) {
                if(CopyRates(Symbol(), detailTF, firstBarTime, 1, ratesForHighLow) > 0) {
                    g_NYHigh = ratesForHighLow[0].high;
                    g_NYLow  = ratesForHighLow[0].low;
                } else {
                    g_NYHigh = 0; g_NYLow = 0;
                }
            }
        }
        g_NYSessionProcessed = false;

        int firstBarShift = iBarShift(Symbol(), detailTF, g_NYOpenTimeActual, false);
        int currentBarShift = iBarShift(Symbol(), detailTF, currentTime, false);
         if(firstBarShift >=0 && currentBarShift >=0 && firstBarShift >= currentBarShift) {
            int barsInSessionSoFar = firstBarShift - currentBarShift + 1;
            if (barsInSessionSoFar > 0) {
                MqlRates sessionRates[];
                int copied = CopyRates(Symbol(), detailTF, currentBarShift, barsInSessionSoFar, sessionRates);
                if (copied == barsInSessionSoFar && copied > 0) {
                    double sessionH = sessionRates[0].high;
                    double sessionL = sessionRates[0].low;
                    for (int k = 1; k < copied; k++) {
                        if (sessionRates[k].high > sessionH) sessionH = sessionRates[k].high;
                        if (sessionRates[k].low < sessionL) sessionL = sessionRates[k].low;
                    }
                    g_NYHigh = sessionH;
                    g_NYLow  = sessionL;
                }
            }
        }
    }
    else if (currentTime >= nyCloseToday && g_NYOpenTimeActual == nyOpenToday && !g_NYSessionProcessed)
    {
        g_NYSessionProcessed = true;
        // PrintFormat("UpdateActualHL: Sesión NY (Hoy) Cerrada. H:%.5f L:%.5f (Abrió: %s, CerróTeórico: %s)", g_NYHigh, g_NYLow, TimeToString(g_NYOpenTimeActual), TimeToString(nyCloseToday));
    }
}



//+------------------------------------------------------------------+
//| GetADXValues - Obtiene valores de ADX, +DI, -DI                  |
//+------------------------------------------------------------------+
bool GetADXValues(string symbol, ENUM_TIMEFRAMES tf, int period, int barShift, double &adxVal, double &plusDiVal, double &minusDiVal)
{
   // Implementación (del código original o una versión robusta)
   // ...
   // Asegurar manejo de INVALID_HANDLE y errores de CopyBuffer
   // ...
   int adxHandle = iADX(symbol, tf, period);
   if(adxHandle == INVALID_HANDLE)
   {
      PrintFormat("GetADXValues: Error al crear handle de iADX(%s, %s, %d). Code=%d", symbol, EnumToString(tf), period, GetLastError());
      return false;
   }
   double adxBuffer[], plusDiBuffer[], minusDiBuffer[];
   if(CopyBuffer(adxHandle, 0, barShift, 1, adxBuffer) <= 0 ||
      CopyBuffer(adxHandle, 1, barShift, 1, plusDiBuffer) <= 0 ||
      CopyBuffer(adxHandle, 2, barShift, 1, minusDiBuffer) <= 0)
   {
      // No siempre es un error crítico si es por falta de datos calculados al inicio.
      // if(GetLastError() != ERR_SERIES_NOT_AVAILABLED_FOR_INDICATOR_CALCULATIONS && GetLastError() != ERR_HISTORY_WILL_UPDATED)
      //    PrintFormat("GetADXValues: Error CopyBuffer ADX(%s, %s). Code=%d", symbol, EnumToString(tf), GetLastError());
      return false;
   }
   adxVal    = adxBuffer[0];
   plusDiVal = plusDiBuffer[0];
   minusDiVal= minusDiBuffer[0];
   return true;
}

//+------------------------------------------------------------------+
//| GetEMAValue - Obtiene valor de una EMA                           |
//+------------------------------------------------------------------+
double GetEMAValue(string symbol, ENUM_TIMEFRAMES tf, int periodEMA, int barShift=0)
{
   // Implementación (del código original o una versión robusta)
   // ...
   int maHandle = iMA(symbol, tf, periodEMA, 0, MODE_EMA, PRICE_CLOSE);
   if(maHandle == INVALID_HANDLE)
   {
      PrintFormat("GetEMAValue: Error al crear handle de iMA(%s, %s, %d EMA). Code=%d", symbol, EnumToString(tf), periodEMA, GetLastError());
      return 0.0;
   }
   double maBuffer[];
   if(CopyBuffer(maHandle, 0, barShift, 1, maBuffer) <= 0)
   {
      // if(GetLastError() != ERR_SERIES_NOT_AVAILABLED_FOR_INDICATOR_CALCULATIONS && GetLastError() != ERR_HISTORY_WILL_UPDATED)
      //    PrintFormat("GetEMAValue: Error CopyBuffer EMA(%s, %s). Code=%d", symbol, EnumToString(tf), GetLastError());
      return 0.0;
   }
   return maBuffer[0];
}

//+------------------------------------------------------------------+
//| ComputeATR - Calcula el ATR para un timeframe y período dados    |
//+------------------------------------------------------------------+
double ComputeATR(ENUM_TIMEFRAMES tf, int period, int shift = 0)
{
    // Implementación (del código original o una versión robusta)
    // ...
   if(period <=0) return 0.0;
   double atr_buffer[];
   // Usar un handle por TF y período podría ser más eficiente si se llama muy frecuentemente con los mismos params.
   // Por ahora, creamos el handle cada vez para simplicidad.
   int atrHandle = iATR(Symbol(), tf, period);
   if(atrHandle == INVALID_HANDLE){
       PrintFormat("ComputeATR: Error creando handle ATR(%s, %s, %d). Code: %d", Symbol(), EnumToString(tf), period, GetLastError());
       return 0.0;
   }
   if(CopyBuffer(atrHandle, 0, shift, 1, atr_buffer) > 0) {
      // IndicatorRelease(atrHandle); // No liberar si se van a usar handles estáticos/cacheados
      return atr_buffer[0];
   }
   else
   {
      // if(GetLastError() != ERR_SERIES_NOT_AVAILABLED_FOR_INDICATOR_CALCULATIONS && GetLastError() != ERR_HISTORY_WILL_UPDATED)
      //    PrintFormat("ComputeATR: Error al copiar buffer ATR en %s. Code: %d", EnumToString(tf), GetLastError());
      // IndicatorRelease(atrHandle);
      return 0.0;
   }
}

//+------------------------------------------------------------------+
//| CalculateLotSize - Calcula el tamaño del lote basado en riesgo   |
//+------------------------------------------------------------------+
double CalculateLotSize(double stopLossValue) // stopLossValue es el tamaño del SL en PRECIO (no pips)
{
   // Usar el input LotSize si es un lote fijo y positivo, sino calcular por riesgo.
   if(LotSize > 0 && LotSize >= SymbolInfoDouble(Symbol(), SYMBOL_VOLUME_MIN))
   {
      // Asegurar que el lote fijo cumpla con el step y min/max del broker
      double minVolume = SymbolInfoDouble(Symbol(), SYMBOL_VOLUME_MIN);
      double maxVolume = SymbolInfoDouble(Symbol(), SYMBOL_VOLUME_MAX);
      double volumeStep = SymbolInfoDouble(Symbol(), SYMBOL_VOLUME_STEP);
      if(minVolume <=0) minVolume = 0.01;
      if(volumeStep <=0) volumeStep = 0.01;
      if(maxVolume <=0) maxVolume = 1000; // Un valor grande por defecto

      double finalLot = LotSize;
      finalLot = MathMax(minVolume, finalLot);
      finalLot = MathMin(maxVolume, finalLot);
      finalLot = MathRound(finalLot / volumeStep) * volumeStep;
      return NormalizeDouble(finalLot,2);
   }

   // Cálculo de Lote por Riesgo (si LotSize no es un valor fijo válido)
   double riskPercentPerTrade = 0.5; // Input para esto? Por ahora, 0.5%
   double accountBalance = AccountInfoDouble(ACCOUNT_BALANCE);
   if(accountBalance <= 0) return SymbolInfoDouble(Symbol(), SYMBOL_VOLUME_MIN);

   double riskAmountInAccountCurrency = accountBalance * (riskPercentPerTrade / 100.0);
   if(stopLossValue <= 0) return SymbolInfoDouble(Symbol(), SYMBOL_VOLUME_MIN); // Necesita un SL válido

   // Calcular el valor por pip/punto en la moneda de la cuenta
   double tickValue = SymbolInfoDouble(Symbol(), SYMBOL_TRADE_TICK_VALUE);
   double tickSize  = SymbolInfoDouble(Symbol(), SYMBOL_TRADE_TICK_SIZE);
   double point     = SymbolInfoDouble(Symbol(), SYMBOL_POINT);

   if(tickValue <= 0 || tickSize <= 0 || point <= 0)
   {
      PrintFormat("CalculateLotSize: Información de símbolo inválida para %s (TickValue:%.5f, TickSize:%.5f, Point:%.5f)",
                  Symbol(), tickValue, tickSize, point);
      return SymbolInfoDouble(Symbol(), SYMBOL_VOLUME_MIN);
   }

   double valuePerPoint = tickValue / tickSize * point; // Valor de 1 punto en moneda de la cuenta
   if(valuePerPoint <= 0)
   {
       PrintFormat("CalculateLotSize: valuePerPoint inválido (%.5f) para %s", valuePerPoint, Symbol());
       return SymbolInfoDouble(Symbol(), SYMBOL_VOLUME_MIN);
   }
   
   // stopLossValue es la diferencia de precio del SL (ej. entry - sl_price). Asegurarse que sea positivo.
   if(stopLossValue <= point) // SL demasiado pequeño, usar un mínimo
   {
        PrintFormat("CalculateLotSize: stopLossValue (%.5f) demasiado pequeño. Usando SL mínimo de input StopLossPips (%d).", stopLossValue, StopLossPips);
        int digits = (int)SymbolInfoInteger(Symbol(), SYMBOL_DIGITS);
        double pipsFactor = (digits==3||digits==5||digits==1) ? 10.0 : 1.0;
        stopLossValue = StopLossPips * point * pipsFactor;
        if(stopLossValue <=0) stopLossValue = 10 * point * pipsFactor; // Fallback aun mayor
   }


   double calculatedLot = riskAmountInAccountCurrency / (stopLossValue * valuePerPoint);
   // Ajustar a mínimo, máximo y step del broker
   double minVolume = SymbolInfoDouble(Symbol(), SYMBOL_VOLUME_MIN);
   double maxVolume = SymbolInfoDouble(Symbol(), SYMBOL_VOLUME_MAX);
   double volumeStep = SymbolInfoDouble(Symbol(), SYMBOL_VOLUME_STEP);
   if(minVolume <=0) minVolume = 0.01;
   if(volumeStep <=0) volumeStep = 0.01;
   if(maxVolume <=0) maxVolume = 1000;

   calculatedLot = MathMax(minVolume, calculatedLot);
   calculatedLot = MathMin(maxVolume, calculatedLot);
   calculatedLot = MathRound(calculatedLot / volumeStep) * volumeStep;
   
   if(calculatedLot < minVolume) calculatedLot = minVolume; // Última verificación

   return NormalizeDouble(calculatedLot, 2);
}

//+------------------------------------------------------------------+
//| IsVolumeTrendingUp - Verifica si el volumen ha sido creciente    |
//+------------------------------------------------------------------+
bool IsVolumeTrendingUp(ENUM_TIMEFRAMES tf, int barIndexShift, int lookback=3, double multiplier=1.0)
{
   if(lookback <= 0) return false;
   long volumes[];
   if(CopyTickVolume(Symbol(), tf, barIndexShift, lookback + 1, volumes) != lookback + 1) // +1 para comparar con el anterior
      return false;

   ArraySetAsSeries(volumes, true); // volumes[0] es la barra actual (según barIndexShift), volumes[1] la anterior

   for(int i = 0; i < lookback; i++)
   {
      if(volumes[i] <= volumes[i+1] * multiplier) // Volumen no es mayor (o significativamente mayor) que el anterior
         return false;
   }
   return true; // Volumen fue consistentemente creciente
}

//+------------------------------------------------------------------+
//| Funciones de Detección de Liquidez (Implementación de Sección 4) |
//+------------------------------------------------------------------+
void AddLiquidityZone(double price, bool isBuySide, datetime time, double strength, string type,
                      LiquidityScope scope, int touchCount = 1, bool isClean = false,
                      double tolerancePips = 1.0) // tolerancePips ya está en AddLiquidityZone de la parte 1
{
    // Implementación de AddLiquidityZone (ya proporcionada en la respuesta anterior de la Sección 4)
    // ... Copiar la función AddLiquidityZone completa aquí ...
    double point = SymbolInfoDouble(Symbol(), SYMBOL_POINT);
    double tolerance = tolerancePips * point * ((Digits() % 2 == 1 && point < 0.001) ? 10 : 1); // Ajuste para JPY y Oro
    if (tolerance <= 0 && point > 0) tolerance = tolerancePips * point; // Fallback si el ajuste anterior da 0
    else if (tolerance <= 0) tolerance = tolerancePips * 0.0001;


    bool exists = false;
    int existingIndex = -1;
    for(int i = ArraySize(liquidityZones) - 1; i >= 0; i--)
    {
        if(liquidityZones[i].isBuySide == isBuySide && MathAbs(liquidityZones[i].price - price) <= tolerance)
        {
            if (liquidityZones[i].type == type && liquidityZones[i].scope == scope) {
                 exists = true;
                 existingIndex = i;
                 break;
            }
        }
    }

    if(exists)
    {
        if(strength > liquidityZones[existingIndex].strength ||
           (type == liquidityZones[existingIndex].type && touchCount > liquidityZones[existingIndex].touchCount))
        {
            liquidityZones[existingIndex].price = price;
            liquidityZones[existingIndex].time = time;
            liquidityZones[existingIndex].strength = strength;
            liquidityZones[existingIndex].type = type;
            liquidityZones[existingIndex].scope = scope;
            liquidityZones[existingIndex].touchCount = MathMax(touchCount, liquidityZones[existingIndex].touchCount);
            liquidityZones[existingIndex].isClean = liquidityZones[existingIndex].isClean || isClean;
        }
    }
    else
    {
        LiquidityZone lz;
        lz.price = price;
        lz.isBuySide = isBuySide;
        lz.time = time;
        lz.strength = strength;
        lz.type = type;
        lz.scope = scope;
        lz.touchCount = touchCount;
        lz.isClean = isClean;

        int sz = ArraySize(liquidityZones);
        if(sz < 1000) { // Limitar el tamaño del array para evitar consumo excesivo de memoria
           ArrayResize(liquidityZones, sz + 1);
           liquidityZones[sz] = lz;
        } else {
            // Print("AddLiquidityZone: Límite de zonas de liquidez alcanzado (1000). No se añadió nueva zona.");
        }
    }
}

void UpdateOldHighsLows()
{
    // Implementación de UpdateOldHighsLows (ya proporcionada en la respuesta anterior de la Sección 4)
    // ... Copiar la función UpdateOldHighsLows completa aquí ...
    datetime nowRefTime = iTime(Symbol(), PERIOD_D1, 0); // Usar inicio del día actual como referencia de tiempo

    double dailyHighs[], dailyLows[];
    if(CopyHigh(Symbol(), PERIOD_D1, 1, 1, dailyHighs) > 0 && dailyHighs[0] != 0)
         AddLiquidityZone(dailyHighs[0], true, iTime(Symbol(), PERIOD_D1, 1), inpLiq_StrengthExternalDaily, "PDH", LIQUIDITY_SCOPE_EXTERNAL, 1, true, 0.1);
    if(CopyLow(Symbol(), PERIOD_D1, 1, 1, dailyLows) > 0 && dailyLows[0] != 0)
         AddLiquidityZone(dailyLows[0], false, iTime(Symbol(), PERIOD_D1, 1), inpLiq_StrengthExternalDaily, "PDL", LIQUIDITY_SCOPE_EXTERNAL, 1, true, 0.1);

    double weeklyHighs[], weeklyLows[];
    if(CopyHigh(Symbol(), PERIOD_W1, 1, 1, weeklyHighs) > 0 && weeklyHighs[0] != 0)
         AddLiquidityZone(weeklyHighs[0], true, iTime(Symbol(), PERIOD_W1, 1), inpLiq_StrengthExternalMajor, "PWH", LIQUIDITY_SCOPE_EXTERNAL, 1, true, 0.2);
    if(CopyLow(Symbol(), PERIOD_W1, 1, 1, weeklyLows) > 0 && weeklyLows[0] != 0)
         AddLiquidityZone(weeklyLows[0], false, iTime(Symbol(), PERIOD_W1, 1), inpLiq_StrengthExternalMajor, "PWL", LIQUIDITY_SCOPE_EXTERNAL, 1, true, 0.2);

    double monthlyHighs[], monthlyLows[];
    if(CopyHigh(Symbol(), PERIOD_MN1, 1, 1, monthlyHighs) > 0 && monthlyHighs[0] != 0)
         AddLiquidityZone(monthlyHighs[0], true, iTime(Symbol(), PERIOD_MN1, 1), inpLiq_StrengthExternalMajor + 0.2, "PMH", LIQUIDITY_SCOPE_EXTERNAL, 1, true, 0.5); // PMH/L aún más fuertes
    if(CopyLow(Symbol(), PERIOD_MN1, 1, 1, monthlyLows) > 0 && monthlyLows[0] != 0)
         AddLiquidityZone(monthlyLows[0], false, iTime(Symbol(), PERIOD_MN1, 1), inpLiq_StrengthExternalMajor + 0.2, "PML", LIQUIDITY_SCOPE_EXTERNAL, 1, true, 0.5);
}

void UpdateSessionHighsLows() // Esto es para añadir los H/L de sesiones YA CONCLUIDAS como zonas de liquidez
{
    // Esta función debe ser llamada DESPUÉS de UpdateActualSessionHighsLows si queremos los H/L de la sesión que acaba de cerrar hoy.
    // O, idealmente, buscaría los H/L de las sesiones del día ANTERIOR.
    // Por ahora, usa las variables globales g_AsiaHigh etc. que UpdateActualSessionHighsLows podría haber fijado.
    LiquidityScope sessionScope = LIQUIDITY_SCOPE_EXTERNAL;

    if(g_AsiaSessionProcessed && g_AsiaHigh != 0 && g_AsiaLow != 0) {
        AddLiquidityZone(g_AsiaHigh, true,  g_AsiaCloseTimeActual, inpLiq_StrengthExternalSession, "Prev Asia H", sessionScope);
        AddLiquidityZone(g_AsiaLow,  false, g_AsiaCloseTimeActual, inpLiq_StrengthExternalSession, "Prev Asia L", sessionScope);
    }
    if(g_LondonSessionProcessed && g_LondonHigh != 0 && g_LondonLow != 0) {
        AddLiquidityZone(g_LondonHigh, true,  g_LondonCloseTimeActual, inpLiq_StrengthExternalSession + 0.2, "Prev London H", sessionScope);
        AddLiquidityZone(g_LondonLow,  false, g_LondonCloseTimeActual, inpLiq_StrengthExternalSession + 0.2, "Prev London L", sessionScope);
    }
    // NY H/L del día anterior podría ser PDH/PDL si NY es la última sesión.
    // Esta función sigue siendo un área de mejora para la precisión histórica de los H/L de sesión.
}


void DetectLiquidity()
{
    // Implementación de DetectLiquidity (ya proporcionada en la respuesta anterior de la Sección 4)
    // ... Copiar la función DetectLiquidity completa aquí ...
    if(TimeCurrent() - g_lastFullUpdateTime < g_updateFrequencySeconds / 2 && ArraySize(liquidityZones) > 0) return; // No recalcular tan agresivamente si ya hay zonas

    ArrayResize(liquidityZones, 0); // Limpiar antes de repoblar
    double point = SymbolInfoDouble(Symbol(), SYMBOL_POINT);
    double eqTolerancePoints = inpLiq_EQH_EQL_TolPips * point * ((Digits() % 2 == 1 && point < 0.001) ? 10:1);
    if (eqTolerancePoints <= 0 && point > 0) eqTolerancePoints = inpLiq_EQH_EQL_TolPips * point;
    else if(eqTolerancePoints <=0) eqTolerancePoints = inpLiq_EQH_EQL_TolPips * 0.0001;


    UpdateOldHighsLows();    // PDH/L, PWH/L, PMH/L - EXTERNAL
    UpdateSessionHighsLows(); // H/L de sesiones pasadas (idealmente día anterior) - EXTERNAL

    ENUM_TIMEFRAMES tfsToScan[] = {PERIOD_M15, PERIOD_H1, PERIOD_H4};
    int pivotStrengthForFractal = 2;

    for(int tf_idx = 0; tf_idx < ArraySize(tfsToScan); tf_idx++)
    {
        ENUM_TIMEFRAMES currentTF = tfsToScan[tf_idx];
        int totalBarsCurrentTF = iBars(Symbol(), currentTF);
        int lookbackForTFSwings = inpLiq_SwingLookback;
        if(currentTF == PERIOD_H1) lookbackForTFSwings = inpLiq_SwingLookback * 2; // Mirar más atrás en H1/H4
        if(currentTF == PERIOD_H4) lookbackForTFSwings = inpLiq_SwingLookback * 4;
        lookbackForTFSwings = MathMin(lookbackForTFSwings, totalBarsCurrentTF - (pivotStrengthForFractal * 2 + 5)); // Asegurar que no exceda las barras disponibles
        if(lookbackForTFSwings <= pivotStrengthForFractal *2) continue;


        MqlRates ratesTF[];
        if(CopyRates(Symbol(), currentTF, 0, lookbackForTFSwings + pivotStrengthForFractal * 2 + 1, ratesTF) <= pivotStrengthForFractal*2) continue;
        ArraySetAsSeries(ratesTF, true);

        SwingPoint recentSwingsTF[];
        int maxRecentSwingsToStore = 30; // Aumentar para mejor detección de EQH/L

        for(int i = pivotStrengthForFractal; i < ArraySize(ratesTF) - pivotStrengthForFractal; i++)
        {
            if(ArraySize(recentSwingsTF) >= maxRecentSwingsToStore*2) break; // Limitar el array de swings

            double currentRateHigh = ratesTF[i].high;
            double currentRateLow = ratesTF[i].low;
            datetime currentRateTime = ratesTF[i].time;
            bool isSwingHigh = true, isSwingLow = true;

            for(int j = 1; j <= pivotStrengthForFractal; j++)
            {
                if(ratesTF[i-j].high > currentRateHigh || ratesTF[i+j].high > currentRateHigh) isSwingHigh = false;
                if(ratesTF[i-j].low < currentRateLow || ratesTF[i+j].low < currentRateLow) isSwingLow = false;
                if(!isSwingHigh && !isSwingLow) break;
            }

            LiquidityScope swingScope = LIQUIDITY_SCOPE_INTERNAL;
            double swingStrength = inpLiq_StrengthSwingInternalBase;
            if(currentTF == PERIOD_H1) swingStrength += 0.5; else if(currentTF == PERIOD_H4) swingStrength += 1.0;

            if(isSwingHigh)
            {
                AddLiquidityZone(currentRateHigh, true, currentRateTime, swingStrength, "Swing H " + EnumToString(currentTF), swingScope,1,false,0.2);
                SwingPoint sp = {currentRateTime, currentRateHigh, true};
                int rs_sz = ArraySize(recentSwingsTF); ArrayResize(recentSwingsTF, rs_sz+1); recentSwingsTF[rs_sz] = sp;
                i += pivotStrengthForFractal -1; // -1 porque el loop incrementa i
            }
            else if(isSwingLow)
            {
                AddLiquidityZone(currentRateLow, false, currentRateTime, swingStrength, "Swing L " + EnumToString(currentTF), swingScope,1,false,0.2);
                SwingPoint sp = {currentRateTime, currentRateLow, false};
                int rs_sz = ArraySize(recentSwingsTF); ArrayResize(recentSwingsTF, rs_sz+1); recentSwingsTF[rs_sz] = sp;
                i += pivotStrengthForFractal -1;
            }
        }

        for(int i = 0; i < ArraySize(recentSwingsTF); i++)
        {
            int touches = 1;
            for(int j = i + 1; j < ArraySize(recentSwingsTF); j++)
            {
                if(recentSwingsTF[j].isHigh == recentSwingsTF[i].isHigh &&
                   MathAbs(recentSwingsTF[j].price - recentSwingsTF[i].price) <= eqTolerancePoints)
                {
                    touches++;
                }
            }

            if(touches >= 2)
            {
                double eqPrice = recentSwingsTF[i].price;
                datetime eqTime = recentSwingsTF[i].time;
                string eqType = (recentSwingsTF[i].isHigh ? "EQH " : "EQL ") + EnumToString(currentTF);
                double eqStrength = inpLiq_StrengthEQH_EQL_Standard;
                bool isCleanEQ = true;
                int cleanLevelCount = 0;

                for(int k=i; k < ArraySize(recentSwingsTF) && cleanLevelCount < touches; k++)
                {
                     if(recentSwingsTF[k].isHigh == recentSwingsTF[i].isHigh &&
                        MathAbs(recentSwingsTF[k].price - recentSwingsTF[i].price) <= eqTolerancePoints * 0.5)
                     {
                         int barIdx = iBarShift(Symbol(), currentTF, recentSwingsTF[k].time, true); // exact = true
                         if(barIdx >=0)
                         {
                             MqlRates eqRateL[]; // Renombrar para evitar conflicto
                             if(CopyRates(Symbol(), currentTF, barIdx, 1, eqRateL)>0)
                             {
                                 double range = eqRateL[0].high - eqRateL[0].low;
                                 double body = MathAbs(eqRateL[0].open - eqRateL[0].close);
                                 if(range > point && (body / range * 100.0) > inpLiq_EQHCandleBodyMaxPercent)
                                 {
                                     isCleanEQ = false;
                                 }
                             } else isCleanEQ = false; // No se pudo obtener la vela, asumir no limpio
                         } else isCleanEQ = false; // No se encontró la barra, asumir no limpio
                         cleanLevelCount++;
                     }
                }
                
                if(touches >= inpLiq_MinTouchesEQH_EQL_Clean && isCleanEQ) {
                    eqStrength = inpLiq_StrengthEQH_EQL_Clean;
                } else if (!isCleanEQ && touches >=2) {
                    eqStrength = inpLiq_StrengthEQH_EQL_Standard - 0.5;
                }

                LiquidityScope eqScope = LIQUIDITY_SCOPE_INTERNAL;
                AddLiquidityZone(eqPrice, recentSwingsTF[i].isHigh, eqTime, eqStrength, eqType, eqScope, touches, isCleanEQ, inpLiq_EQH_EQL_TolPips);
                 // No avanzar 'i' aquí, AddLiquidityZone debe manejar la actualización si ya existe.
            }
        }
    }
    // PrintFormat("DetectLiquidity: %d zonas de liquidez detectadas.", ArraySize(liquidityZones));
}


//+------------------------------------------------------------------+
//| DetectFairValueGaps - Detecta FVGs en el timeframe especificado  |
//+------------------------------------------------------------------+
void DetectFairValueGaps(ENUM_TIMEFRAMES fvgTF)
{
   ArrayResize(fairValueGaps, 0); // Limpiar array antes de repoblar
   int totalBars = iBars(Symbol(), fvgTF);
   if(totalBars < 3) return;

   MqlRates rates[];
   // Copiar un número razonable de barras para buscar FVGs recientes
   int barsToCopy = MathMin(totalBars, 300); // Buscar en las últimas 300 velas del fvgTF
   if(CopyRates(Symbol(), fvgTF, 0, barsToCopy, rates) != barsToCopy) {
      // PrintFormat("DetectFairValueGaps: Error al copiar tasas para %s.", EnumToString(fvgTF));
      return;
   }
   ArraySetAsSeries(rates, true); // rates[0] es la vela actual (en formación o recién cerrada)

   double point = SymbolInfoDouble(Symbol(), SYMBOL_POINT);
   // Usar un tamaño mínimo de FVG general (puede ser un input si se necesita más control)
   double minFVGSizePipsGeneric = 0.2; // FVG muy pequeños pueden no ser relevantes
   double minFVGSizePoints = minFVGSizePipsGeneric * point * ((Digits() % 2 == 1 && point < 0.001) ? 10:1);
    if (minFVGSizePoints <= 0 && point > 0) minFVGSizePoints = minFVGSizePipsGeneric * point;
    else if(minFVGSizePoints <=0) minFVGSizePoints = minFVGSizePipsGeneric * 0.0001;


   for(int i = 1; i < barsToCopy - 1; i++) // Iterar sobre las velas cerradas
   {
      // Vela 0 (más antigua en el patrón de 3): rates[i+1]
      // Vela 1 (central, la que tiene el desequilibrio): rates[i]
      // Vela 2 (más nueva en el patrón de 3): rates[i-1]

      double c0_High = rates[i+1].high;
      double c0_Low  = rates[i+1].low;
      double c2_High = rates[i-1].high;
      double c2_Low  = rates[i-1].low;

      FairValueGap fvg;
      fvg.isFilled = false; // Por defecto no está lleno
      fvg.isPartiallyFilled = false; // Por defecto no está parcialmente lleno

      // Bullish FVG: c0_High < c2_Low
      if(c0_High < c2_Low && (c2_Low - c0_High) >= minFVGSizePoints)
      {
         fvg.startPrice = c0_High; // Límite inferior del FVG alcista
         fvg.endPrice   = c2_Low;   // Límite superior del FVG alcista
         fvg.isBullish  = true;
         fvg.timeFirstCandle = rates[i+1].time;
         fvg.timeThirdCandle = rates[i-1].time;

         // Chequear si está lleno o parcialmente lleno por velas posteriores a su formación
         for(int k=i-2; k>=0; k--) { // Velas después de la vela 2 (rates[i-1])
             if(rates[k].low <= fvg.startPrice) { fvg.isFilled = true; break; } // Completamente lleno
             if(rates[k].low <= (fvg.startPrice + fvg.endPrice)/2.0) fvg.isPartiallyFilled = true;
             if(rates[k].high < fvg.startPrice) break; // El precio se alejó sin llenarlo
         }


         int sz = ArraySize(fairValueGaps);
         ArrayResize(fairValueGaps, sz + 1);
         fairValueGaps[sz] = fvg;
      }
      // Bearish FVG: c0_Low > c2_High
      else if(c0_Low > c2_High && (c0_Low - c2_High) >= minFVGSizePoints)
      {
         fvg.startPrice = c2_High; // Límite inferior del FVG bajista
         fvg.endPrice   = c0_Low;   // Límite superior del FVG bajista
         fvg.isBullish  = false;
         fvg.timeFirstCandle = rates[i+1].time;
         fvg.timeThirdCandle = rates[i-1].time;

         for(int k=i-2; k>=0; k--) {
             if(rates[k].high >= fvg.endPrice) { fvg.isFilled = true; break; }
             if(rates[k].high >= (fvg.startPrice + fvg.endPrice)/2.0) fvg.isPartiallyFilled = true;
             if(rates[k].low > fvg.endPrice) break;
         }

         int sz = ArraySize(fairValueGaps);
         ArrayResize(fairValueGaps, sz + 1);
         fairValueGaps[sz] = fvg;
      }
   }
   // PrintFormat("DetectFairValueGaps: %d FVGs detectados en %s.", ArraySize(fairValueGaps), EnumToString(fvgTF));
}

//+------------------------------------------------------------------+
//| FindLastFVG - Busca el último FVG no mitigado en la dirección   |
//| especificada, formado después de 'afterTime' (si se provee)    |
//+------------------------------------------------------------------+
FairValueGap FindLastFVG(ENUM_TIMEFRAMES timeframe, int lookbackBars, int barStartSearchShift,
                         bool fvgDirectionBullish, datetime afterTime = 0, double minSizePips = 0.5)
{
    // Esta es la implementación de FindLastFVGForConfirmation, renombrada y generalizada
    FairValueGap fvgFound = {0,0,false,0,0,false,false};
    MqlRates rates[];
    // barStartSearchShift es el shift desde la barra actual (0 = actual, 1 = anterior cerrada)
    if(CopyRates(Symbol(), timeframe, barStartSearchShift, lookbackBars + 2, rates) < 3) { // +2 para las 3 velas del FVG
        // PrintFormat("FindLastFVG: No hay suficientes datos en %s. Shift: %d, Lookback: %d", EnumToString(timeframe), barStartSearchShift, lookbackBars);
        return fvgFound;
    }
    ArraySetAsSeries(rates, true); // rates[0] es la barra correspondiente a barStartSearchShift

    double point = SymbolInfoDouble(Symbol(), SYMBOL_POINT);
    double minSizePoints = minSizePips * point * ((Digits() % 2 == 1 && point < 0.001) ? 10:1);
    if (minSizePoints <= 0 && point > 0) minSizePoints = minSizePips * point;
    else if(minSizePoints <=0) minSizePoints = minSizePips * 0.0001;


    // Iterar desde la vela más reciente (índice 0, que es la barra barStartSearchShift) hacia atrás
    // El FVG se forma por 3 velas. Si rates[i] es la vela central,
    // las 3 velas son rates[i+1] (vela 0), rates[i] (vela 1), rates[i-1] (vela 2).
    for(int i = 1; i < ArraySize(rates) - 1 && i < lookbackBars +1 ; i++)
    {
        if(afterTime > 0 && rates[i].time <= afterTime) continue; // FVG debe ser posterior a afterTime

        double c0_High = rates[i+1].high;
        double c0_Low  = rates[i+1].low;
        double c2_High = rates[i-1].high;
        double c2_Low  = rates[i-1].low;

        bool currentFVGisBullish = false;
        double currentFVGStart = 0, currentFVGEnd = 0;

        if(fvgDirectionBullish) // Buscamos FVG Alcista
        {
            if(c0_High < c2_Low && (c2_Low - c0_High) >= minSizePoints)
            {
                currentFVGisBullish = true;
                currentFVGStart = c0_High;
                currentFVGEnd   = c2_Low;
            } else continue; // No es el FVG alcista que buscamos
        }
        else // Buscamos FVG Bajista
        {
            if(c0_Low > c2_High && (c0_Low - c2_High) >= minSizePoints)
            {
                currentFVGisBullish = false;
                currentFVGStart = c2_High;
                currentFVGEnd   = c0_Low;
            } else continue; // No es el FVG bajista que buscamos
        }
        
        // Encontrado un FVG en la dirección correcta. Ahora verificar si está (parcialmente) sin llenar.
        bool filled = false;
        bool partially_filled = false;
        // Chequear llenado por velas POSTERIORES a la formación del FVG (posteriores a rates[i-1])
        for(int k=i-2; k>=0; k--) {
             if(currentFVGisBullish){
                 if(rates[k].low <= currentFVGStart) { filled = true; break; }
                 if(rates[k].low <= (currentFVGStart + currentFVGEnd)/2.0) partially_filled = true;
                 if(rates[k].high < currentFVGStart && !partially_filled) break; // Se alejó sin tocar
             } else { // Bearish FVG
                 if(rates[k].high >= currentFVGEnd) { filled = true; break; }
                 if(rates[k].high >= (currentFVGStart + currentFVGEnd)/2.0) partially_filled = true;
                 if(rates[k].low > currentFVGEnd && !partially_filled) break; // Se alejó sin tocar
             }
        }

        if(!filled) // Si no está completamente lleno, es un candidato válido
        {
            fvgFound.startPrice = currentFVGStart;
            fvgFound.endPrice   = currentFVGEnd;
            fvgFound.isBullish  = currentFVGisBullish;
            fvgFound.timeFirstCandle = rates[i+1].time;
            fvgFound.timeThirdCandle = rates[i-1].time;
            fvgFound.isFilled = filled; // Será false
            fvgFound.isPartiallyFilled = partially_filled;
            /*
            PrintFormat("FindLastFVG: Encontrado FVG %s en %s. Start: %.5f, End: %.5f, Time1: %s, Time3: %s, ParcialFill: %s",
                       fvgFound.isBullish ? "Alcista" : "Bajista", EnumToString(timeframe),
                       fvgFound.startPrice, fvgFound.endPrice, TimeToString(fvgFound.timeFirstCandle),TimeToString(fvgFound.timeThirdCandle),
                       fvgFound.isPartiallyFilled ? "Si":"No");
            */
            return fvgFound; // Devolver el más reciente no completamente lleno
        }
    }
    return fvgFound; // Devuelve vacía si no se encontró ninguno no lleno
}

//+------------------------------------------------------------------+
//| DetectOrderBlocks - Detecta OBs en el timeframe especificado     |
//+------------------------------------------------------------------+
void DetectOrderBlocks(ENUM_TIMEFRAMES obTF)
{
   ArrayResize(orderBlocks, 0);
   int totalBars = iBars(Symbol(), obTF);
   if(totalBars < 20) { // Necesitamos suficientes barras para contexto y desplazamiento
      // PrintFormat("DetectOrderBlocks: No hay suficientes barras en %s para detectar OBs.", EnumToString(obTF));
      return;
   }

   MqlRates rates[];
   int barsToScan = MathMin(totalBars, 150); // Analizar las últimas 150 velas del obTF
   if(CopyRates(Symbol(), obTF, 0, barsToScan, rates) != barsToScan) {
      // PrintFormat("DetectOrderBlocks: Error al copiar tasas para %s.", EnumToString(obTF));
      return;
   }
   ArraySetAsSeries(rates, true); // rates[0] es la vela actual (en formación o recién cerrada)

   double point = SymbolInfoDouble(Symbol(), SYMBOL_POINT);
   double minRangePoints = inpOB_MinRangePips * point * ((Digits() % 2 == 1 && point < 0.001) ? 10:1);
    if (minRangePoints <= 0 && point > 0) minRangePoints = inpOB_MinRangePips * point;
    else if(minRangePoints <=0) minRangePoints = inpOB_MinRangePips * 0.0001;

   // Determinar el sesgo direccional para buscar OBs (ej. usar H4 bias)
   // Si H4 es alcista, buscamos OBs alcistas (que son velas bajistas previas a un movimiento alcista).
   // Si H4 es bajista, buscamos OBs bajistas (que son velas alcistas previas a un movimiento bajista).
   bool lookForBullishOBs = g_H4BiasIsBullish; // Asumimos que g_H4BiasIsBullish está actualizado

   for(int i = inpOB_DisplacementBars; i < barsToScan - 1; i++) // Empezar después de tener espacio para el desplazamiento
   {                                                           // i es la vela candidata a ser el OB
                                                               // rates[i-1], rates[i-2]... son las velas de desplazamiento
      OrderBlock ob;
      ob.isValid = false;

      // Vela candidata a OB:
      // Si buscamos OB Alcista (esperamos COMPRAS), la vela del OB es BAJISTA.
      // Si buscamos OB Bajista (esperamos VENTAS), la vela del OB es ALCISTA.
      if(lookForBullishOBs && rates[i].close < rates[i].open) // Vela bajista, posible OB Alcista
      {
         ob.isBullish = true;
      }
      else if(!lookForBullishOBs && rates[i].close > rates[i].open) // Vela alcista, posible OB Bajista
      {
         ob.isBullish = false;
      }
      else
      {
         continue; // No es una vela candidata para el sesgo actual
      }

      ob.openPrice = rates[i].open;
      ob.closePrice = rates[i].close;
      ob.highPrice = rates[i].high;
      ob.lowPrice = rates[i].low;
      ob.time = rates[i].time;

      // 1. Validar tamaño mínimo del OB
      if((ob.highPrice - ob.lowPrice) < minRangePoints) continue;

      // 2. Validar Desplazamiento (displacement)
      // El desplazamiento debe ocurrir en las N velas SIGUIENTES al OB (índices menores en 'rates')
      bool displacementConfirmed = false;
      double totalDisplacementValue = 0;
      int displacementCandlesCount = 0;
      double atrOBTF = ComputeATR(obTF, ATRPeriod_M15); // Usar ATR del TF del OB
      if(atrOBTF <=0) atrOBTF = (ob.highPrice-ob.lowPrice) > 0 ? (ob.highPrice-ob.lowPrice) : point*10; // Fallback

      for(int k = 1; k <= inpOB_DisplacementBars; k++)
      {
         if(i-k < 0) break; // No hay suficientes velas para el desplazamiento
         displacementCandlesCount++;
         if(ob.isBullish) // OB Alcista (vela OB bajista), desplazamiento debe ser ALCISTA
         {
            // El cierre de la vela de desplazamiento debe superar el MÁXIMO del OB
            if(rates[i-k].close > ob.highPrice) totalDisplacementValue += (rates[i-k].close - ob.highPrice);
            if(rates[i-k].high > ob.highPrice + atrOBTF * inpOB_StrongDisplacementATRRatio) { // Fuerte desplazamiento en una vela
                displacementConfirmed = true;
                break;
            }
         }
         else // OB Bajista (vela OB alcista), desplazamiento debe ser BAJISTA
         {
            // El cierre de la vela de desplazamiento debe estar por debajo del MÍNIMO del OB
            if(rates[i-k].close < ob.lowPrice) totalDisplacementValue += (ob.lowPrice - rates[i-k].close);
             if(rates[i-k].low < ob.lowPrice - atrOBTF * inpOB_StrongDisplacementATRRatio) {
                displacementConfirmed = true;
                break;
            }
         }
      }

      if(!displacementConfirmed && displacementCandlesCount > 0) {
          // Si no hubo un desplazamiento de una sola vela fuerte, chequear desplazamiento acumulado
          if (totalDisplacementValue / displacementCandlesCount > atrOBTF * 0.7) // Desplazamiento promedio > 0.7 ATR
             displacementConfirmed = true;
      }
      
      if(!displacementConfirmed) continue;

      // 3. Evaluar Calidad y si está Barrido
      ob.isValid = true; // Cumplió tamaño y desplazamiento
      ob.quality = AssessOBQuality(ob, obTF); // Pasamos el TF del OB
      ob.isSwept = IsOBSwept(ob, obTF);

      if(ob.quality >= inpMinOBQualityForEntry && !ob.isSwept)
      {
         int sz = ArraySize(orderBlocks);
         if(sz < 200) { // Limitar número de OBs almacenados
            ArrayResize(orderBlocks, sz + 1);
            orderBlocks[sz] = ob;
         } else {
            // Podríamos reemplazar el de menor calidad si el array está lleno
         }
      }
   }
   SortOrderBlocksByQuality(); // Ordenar por calidad descendente
   // PrintFormat("DetectOrderBlocks: %d OBs detectados y válidos en %s.", ArraySize(orderBlocks), EnumToString(obTF));
}

//+------------------------------------------------------------------+
//| AssessOBQuality - Evalúa la calidad de un Order Block            |
//| Considera tamaño, mechas, volumen del OB y calidad del          |
//| desplazamiento posterior.                                        |
//+------------------------------------------------------------------+
double AssessOBQuality(OrderBlock &ob, ENUM_TIMEFRAMES obTF) // ob es el OB a evaluar, obTF es el timeframe en el que se detectó
{
    double quality = 5.0; // Puntuación base de calidad
    double point = SymbolInfoDouble(Symbol(), SYMBOL_POINT);
    if(point <= 0) point = 0.00001; // Fallback para point

    // Calcular ATR del timeframe del Order Block para comparaciones relativas
    double atrOBTF = ComputeATR(obTF, ATRPeriod_M15); // Usar ATRPeriod_M15 como input genérico para el período del ATR
    if(atrOBTF <= point * 0.1) atrOBTF = point * 100; // Fallback si ATR es muy pequeño o cero

    // --- 1. Tamaño Relativo del OB ---
    double obRange = ob.highPrice - ob.lowPrice;
    if(obRange < point) { // OB inválido o demasiado pequeño
        ob.isValid = false;
        return 0.0;
    }
    if(atrOBTF > point) { // Evitar división por cero si ATR es inválido
        ob.relativeSize = obRange / atrOBTF;
        if(ob.relativeSize > 1.2) quality += 1.0;      // Buen tamaño relativo
        else if (ob.relativeSize < 0.6) quality -= 1.0; // OB pequeño en relación al ATR
    } else {
        ob.relativeSize = 1.0; // No se puede calcular ratio, asumir neutro
    }

    // --- 2. Mechas (Wicks) del OB ---
    double bodySize = MathAbs(ob.closePrice - ob.openPrice);
    if (bodySize >= point) // Solo evaluar mechas si hay un cuerpo discernible
    {
        double upperWick = ob.highPrice - MathMax(ob.openPrice, ob.closePrice);
        double lowerWick = MathMin(ob.openPrice, ob.closePrice) - ob.lowPrice;

        // Para un OB Alcista (vela original BAJISTA), una mecha inferior grande es favorable (indica rechazo y compra)
        if(ob.isBullish && lowerWick > bodySize * 0.7 && lowerWick > atrOBTF * 0.3) quality += 0.75;
        // Para un OB Bajista (vela original ALCISTA), una mecha superior grande es favorable (indica rechazo y venta)
        else if(!ob.isBullish && upperWick > bodySize * 0.7 && upperWick > atrOBTF * 0.3) quality += 0.75;
        // Penalizar mechas muy grandes en la dirección opuesta al movimiento esperado
        if(ob.isBullish && upperWick > bodySize * 1.5) quality -= 0.5;
        if(!ob.isBullish && lowerWick > bodySize * 1.5) quality -= 0.5;

    } else { // Cuerpo muy pequeño o inexistente (Doji)
        quality -= 0.5; // Generalmente menos decisivo como OB clásico
    }

    // --- 3. Volumen del Order Block ---
    int obBarIndex = iBarShift(Symbol(), obTF, ob.time, true); // exact=true para encontrar la barra del tiempo del OB
    long obVolume = 0;
    double avgPreviousVolume = 0;

    if(obBarIndex >= 0)
    {
        obVolume = iTickVolume(Symbol(), obTF, obBarIndex); // Volumen de la vela del OB

        // Calcular volumen promedio de N velas ANTERIORES al OB
        long volSum = 0;
        int volBarsCount = 0;
        int totalBarsAvailable = iBars(Symbol(), obTF);
        for(int k = obBarIndex + 1; k <= MathMin(totalBarsAvailable - 1, obBarIndex + 10); k++) // 10 velas anteriores
        {
           volSum += iTickVolume(Symbol(), obTF, k);
           volBarsCount++;
        }
        if(volBarsCount > 0) avgPreviousVolume = (double)volSum / volBarsCount;

        if(avgPreviousVolume > 0 && obVolume > avgPreviousVolume * 1.2) quality += 0.75; // Volumen del OB > promedio
        else if (avgPreviousVolume > 0 && obVolume < avgPreviousVolume * 0.7) quality -= 0.5; // Volumen bajo
    }

    // --- 4. Calidad del Desplazamiento (Displacement) POSTERIOR al OB ---
    if(obBarIndex >= 0) // Solo si encontramos la barra del OB
    {
        int displacementBarsToAnalyze = inpOB_DisplacementBars; // Desde input (ej. 3 barras)
        double totalNetDisplacementFromOB = 0; // Acumulación del movimiento neto desde el extremo del OB
        long displacementVolumeSum = 0;
        int displacementValidCandles = 0;
        int retracementCandlesInDisplacement = 0;
        double maxSingleBarDisplacementRatioATR = 0; // Máximo movimiento de una sola vela de desplazamiento / ATR

        MqlRates displacementCandleArr[1]; // Array para una vela

        for(int k = 1; k <= displacementBarsToAnalyze; k++)
        {
            int displacementCandleIndex = obBarIndex - k; // Velas después del OB (índices menores en serie de tiempo)
            if(displacementCandleIndex < 0) break; // No hay suficientes velas después del OB

            if(CopyRates(Symbol(), obTF, displacementCandleIndex, 1, displacementCandleArr) <= 0) continue; // No se pudo copiar la vela

            MqlRates currentDisplacementCandle = displacementCandleArr[0];
            long currentDisplacementVolume = (long)currentDisplacementCandle.tick_volume;
            double barNetMove = 0; // Movimiento neto de la vela en la dirección esperada del desplazamiento

            if(ob.isBullish) // OB Alcista (vela OB fue bajista), esperamos desplazamiento ALCISTA
            {
                // Movimiento por encima del High del OB
                if(currentDisplacementCandle.close > ob.highPrice) barNetMove = currentDisplacementCandle.close - ob.highPrice;
                else if (currentDisplacementCandle.high > ob.highPrice) barNetMove = (currentDisplacementCandle.high - ob.highPrice) * 0.5; // Considerar mecha parcialmente

                if(currentDisplacementCandle.close < currentDisplacementCandle.open) retracementCandlesInDisplacement++; // Vela bajista en desplazamiento alcista
                if(atrOBTF > point) {
                    double singleBarDispRatio = (currentDisplacementCandle.high - ob.highPrice) / atrOBTF;
                    if(singleBarDispRatio > maxSingleBarDisplacementRatioATR) maxSingleBarDisplacementRatioATR = singleBarDispRatio;
                }
            }
            else // OB Bajista (vela OB fue alcista), esperamos desplazamiento BAJISTA
            {
                // Movimiento por debajo del Low del OB
                if(currentDisplacementCandle.close < ob.lowPrice) barNetMove = ob.lowPrice - currentDisplacementCandle.close;
                else if (currentDisplacementCandle.low < ob.lowPrice) barNetMove = (ob.lowPrice - currentDisplacementCandle.low) * 0.5;

                if(currentDisplacementCandle.close > currentDisplacementCandle.open) retracementCandlesInDisplacement++; // Vela alcista en desplazamiento bajista
                if(atrOBTF > point) {
                     double singleBarDispRatio = (ob.lowPrice - currentDisplacementCandle.low) / atrOBTF;
                    if(singleBarDispRatio > maxSingleBarDisplacementRatioATR) maxSingleBarDisplacementRatioATR = singleBarDispRatio;
                }
            }
            
            if(barNetMove > 0) totalNetDisplacementFromOB += barNetMove;
            displacementVolumeSum += currentDisplacementVolume;
            displacementValidCandles++;
        }

        if(displacementValidCandles > 0)
        {
            double avgDisplacementPerCandle = (atrOBTF > point) ? (totalNetDisplacementFromOB / displacementValidCandles) / atrOBTF : 0; // Normalizado por ATR

            // 4.1. Fuerza y Velocidad del Desplazamiento
            if(avgDisplacementPerCandle > 0.6) quality += 1.25;       // Buen desplazamiento promedio
            else if (avgDisplacementPerCandle < 0.2) quality -= 1.0;  // Desplazamiento débil

            if(maxSingleBarDisplacementRatioATR >= inpOB_StrongDisplacementATRRatio) quality += 1.5; // Una vela movió significativamente

            // 4.2. Volumen del Desplazamiento
            double avgDisplacementVolume = (double)displacementVolumeSum / displacementValidCandles;
            if(avgPreviousVolume > 0 && avgDisplacementVolume > avgPreviousVolume * 1.3) quality += 1.0; // Volumen del desplazamiento > promedio anterior
            else if(avgPreviousVolume > 0 && avgDisplacementVolume < avgPreviousVolume * 0.8) quality -= 0.5;

            // Verificar si el volumen fue creciente durante el desplazamiento (simplificado)
            if(displacementValidCandles > 1) {
                if(IsVolumeTrendingUp(obTF, obBarIndex - displacementValidCandles, displacementValidCandles -1, 1.0)) { // barIndexShift es el inicio del conjunto de velas de desplazamiento
                     quality += 0.5;
                }
            }

            // 4.3. Penalizar Retrocesos Durante el Desplazamiento
            if(retracementCandlesInDisplacement == 0 && displacementValidCandles >=1) quality += 0.5;
            else if (retracementCandlesInDisplacement >= MathCeil(displacementValidCandles / 2.0) && displacementValidCandles > 1) quality -= 1.0;
        }
        else // No hubo suficientes velas para analizar el desplazamiento claro
        {
            quality -= 0.75; // Penalizar si no se ve desplazamiento inmediato
        }
    } else { // No se encontró la barra del OB
        quality -= 1.0; // Penalizar si no se puede encontrar la barra del OB para análisis de volumen/desplazamiento
    }

    // --- 5. Confluencia con FVG (Opcional, pero buen indicador) ---
    // Verificar si el OB (o su desplazamiento inmediato) creó un FVG en la dirección del movimiento esperado.
    if(obBarIndex >= 0 && ob.isValid) // Solo si el OB es válido y encontramos su barra
    {
        // Buscar FVG en las velas inmediatamente después del OB (formado por el desplazamiento)
        // El barStartSearchShift para FindLastFVG sería el índice de la primera vela de desplazamiento.
        int firstDisplacementCandleShift = obBarIndex -1;
        if(firstDisplacementCandleShift >=0) {
            FairValueGap fvgCreatedByDisplacement = FindLastFVG(obTF, inpOB_DisplacementBars + 2, firstDisplacementCandleShift, ob.isBullish, ob.time, 0.1); // Min FVG size 0.1 pips
            if(fvgCreatedByDisplacement.startPrice != 0 && !fvgCreatedByDisplacement.isFilled) // Si se encontró FVG relevante y no lleno
            {
                // Asegurar que el FVG está realmente DESPUÉS del OB y en la dirección correcta
                bool fvgIsAlignedAndRecent = false;
                if(ob.isBullish && fvgCreatedByDisplacement.isBullish && fvgCreatedByDisplacement.timeFirstCandle >= ob.time) {
                     // FVG alcista formado después o con la vela OB, donde el startPrice del FVG es > low de la vela 0 y < high de vela 0 del FVG.
                     // Y el FVG está por ENCIMA del OB.
                     if(fvgCreatedByDisplacement.startPrice > ob.highPrice || fvgCreatedByDisplacement.endPrice > ob.highPrice) fvgIsAlignedAndRecent = true;
                } else if (!ob.isBullish && !fvgCreatedByDisplacement.isBullish && fvgCreatedByDisplacement.timeFirstCandle >= ob.time) {
                     // FVG bajista formado después o con la vela OB.
                     // Y el FVG está por DEBAJO del OB.
                     if(fvgCreatedByDisplacement.endPrice < ob.lowPrice || fvgCreatedByDisplacement.startPrice < ob.lowPrice) fvgIsAlignedAndRecent = true;
                }

                if(fvgIsAlignedAndRecent) quality += 1.0;
            }
        }
    }

    // --- 6. Placeholder para Confluencia HTF y Zona Premium/Discount ---
    // ob.hasHTFConfluence = CheckHTFConfluence(ob); // Necesita implementación
    // if(ob.hasHTFConfluence) quality += 1.0;
    // ob.isPremium = IsPremiumPosition(ob); // Necesita implementación
    // if((ob.isBullish && !ob.isPremium) || (!ob.isBullish && ob.isPremium)) quality += 0.5;


    return MathMax(0.0, MathMin(10.0, quality)); // Limitar calidad entre 0 y 10
}

//+------------------------------------------------------------------+
//| IsOBSwept - Verifica si un Order Block ha sido mitigado/barrido  |
//+------------------------------------------------------------------+
bool IsOBSwept(const OrderBlock &ob, ENUM_TIMEFRAMES obTF)
{
   // Implementación de IsOBSwept (ya proporcionada en la respuesta anterior de la Sección 1)
   // ... Copiar la función IsOBSwept completa aquí ...
   int obIndex = iBarShift(Symbol(), obTF, ob.time, true); // exact = true
   if(obIndex < 0) return true; // No se encontró la barra, asumir barrido para seguridad

   // Buscar desde la vela SIGUIENTE al OB (índice menor) hasta la vela actual (índice 0)
   for(int i = obIndex - 1; i >= 0; i--)
   {
      if(ob.isBullish) // OB Alcista (vela OB bajista). Barrido si el precio baja a su Low o 50%.
      {
         // Para ICT, un toque en el Open o Mean Threshold (50% del rango) del OB es mitigación.
         double obMeanThreshold = (ob.highPrice + ob.lowPrice) / 2.0;
         if(iLow(Symbol(), obTF, i) <= ob.openPrice || iLow(Symbol(), obTF, i) <= obMeanThreshold ) return true;
         // Considerar barrido si toca el Low extremo
         // if(iLow(Symbol(), obTF, i) <= ob.lowPrice) return true;
      }
      else // OB Bajista (vela OB alcista). Barrido si el precio sube a su High o 50%.
      {
         double obMeanThreshold = (ob.highPrice + ob.lowPrice) / 2.0;
         if(iHigh(Symbol(), obTF, i) >= ob.openPrice || iHigh(Symbol(), obTF, i) >= obMeanThreshold) return true;
         // if(iHigh(Symbol(), obTF, i) >= ob.highPrice) return true;
      }
   }
   return false;
}

//+------------------------------------------------------------------+
//| SortOrderBlocksByQuality - Ordena OBs por calidad descendente    |
//+------------------------------------------------------------------+
void SortOrderBlocksByQuality()
{
   // Implementación de SortOrderBlocksByQuality (ya proporcionada)
   // ... Copiar la función SortOrderBlocksByQuality completa aquí ...
    int size = ArraySize(orderBlocks);
    if(size <= 1) return;
    for(int i = 0; i < size - 1; i++) {
        for(int j = 0; j < size - i - 1; j++) {
            if(orderBlocks[j].quality < orderBlocks[j + 1].quality) {
                OrderBlock temp = orderBlocks[j];
                orderBlocks[j] = orderBlocks[j + 1];
                orderBlocks[j + 1] = temp;
            }
        }
    }
}

//+------------------------------------------------------------------+
//| DetectBreakerBlocks - Detecta Breaker Blocks                     |
//+------------------------------------------------------------------+
bool CheckIfPriceTookSignificantLiquidity(double failedSwingPrice, bool isSweepOfHigh, double &outLiquidityStrength)
{
    // Implementación de CheckIfPriceTookSignificantLiquidity (ya proporcionada en la Sección 1.3)
    // ... Copiar la función CheckIfPriceTookSignificantLiquidity completa aquí ...
    outLiquidityStrength = 0;
    double point = SymbolInfoDouble(Symbol(), SYMBOL_POINT);
    double tolerancePips = 2.0;
    double tolerance = tolerancePips * point * ((Digits() % 2 == 1 && point < 0.001) ? 10 : 1);
    if(tolerance <=0 && point >0) tolerance = tolerancePips * point; else if(tolerance<=0) tolerance = tolerancePips * 0.0001;

    for(int i = 0; i < ArraySize(liquidityZones); i++)
    {
        if(liquidityZones[i].isBuySide == isSweepOfHigh)
        {
            if(MathAbs(liquidityZones[i].price - failedSwingPrice) <= tolerance)
            {
                if(liquidityZones[i].strength >= inpMinLiqStrengthForTP - 0.5) // Un poco menos estricto que para TP
                {
                    outLiquidityStrength = liquidityZones[i].strength;
                    return true;
                }
            }
        }
    }
    return false;
}

void DetectBreakerBlocks(ENUM_TIMEFRAMES bbTF, ENUM_TIMEFRAMES obSourceTF) // bbTF es el TF del ChoCH, obSourceTF es el TF del OB original
{
    // Implementación de DetectBreakerBlocks (ya proporcionada y modificada en la Sección 1.3)
    // ... Copiar la función DetectBreakerBlocks completa aquí ...
    ArrayResize(breakerBlocks, 0);
    // Usar orderBlocks ya detectados en obSourceTF. Deben estar ordenados por tiempo (más reciente primero) o calidad.
    // SortOrderBlocksByQuality(); // Asegurar que estén ordenados si es necesario.

    for(int i = 0; i < ArraySize(orderBlocks); i++)
    {
        if(ArraySize(breakerBlocks) >= 10) break; // Limitar número de breakers

        OrderBlock failedOB = orderBlocks[i];
        if(failedOB.time == 0) continue; // OB no válido
        if(iBarShift(Symbol(), obSourceTF, failedOB.time, false) < 0) continue; // No existe en el historial actual

        // Un Breaker se forma a partir de un OB que FUE BARRIDO (isSwept = true)
        // y luego hay un ChoCH/BOS en la dirección opuesta en el bbTF.
        if(!IsOBSwept(failedOB, obSourceTF)) continue; // El OB original debe haber sido barrido

        bool breakerDirectionIsBullish = !failedOB.isBullish; // Breaker es opuesto al OB fallido
        double breakerLevelPrice = failedOB.isBullish ? failedOB.lowPrice : failedOB.highPrice; // Nivel del OB fallido

        // Buscar ChoCH/BOS en bbTF DESPUÉS del tiempo del OB fallido
        int lookbackForShift = inpInvalidation_Lookback; // Usar un lookback razonable para el ChoCH
        // El ChoCH/BOS debe ocurrir DESPUÉS de que el OB fue barrido. IsOBSwept confirma el barrido.
        // El barIndexShift para DetectChoCH/BOS debe ser tal que busque desde el presente hacia atrás.
        datetime shiftConfirmedTime = 0;
        
        // Shift debe ser posterior al tiempo del OB
        // Iterar velas recientes en bbTF
        MqlRates ratesBBTF[];
        int barsToScanBBTF = MathMin(iBars(Symbol(),bbTF)-1, lookbackForShift + 10);
        if(barsToScanBBTF < 5) continue;
        if(CopyRates(Symbol(), bbTF, 0, barsToScanBBTF, ratesBBTF) != barsToScanBBTF) continue;
        ArraySetAsSeries(ratesBBTF, true);

        for(int k=0; k < lookbackForShift; k++) { // k=0 es la última vela cerrada del bbTF
            if(ratesBBTF[k].time <= failedOB.time) break; // ChoCH debe ser después del OB

            if(DetectChoCH(bbTF, k+1, breakerDirectionIsBullish, lookbackForShift) ||
               DetectBOS(bbTF, k+1, breakerDirectionIsBullish, lookbackForShift) )
            {
                 // Verificar que el precio realmente rompió el breakerLevelPrice en la dirección del Breaker
                 // antes de este ChoCH o como parte de él.
                 bool breakerLevelBroken = false;
                 for(int m=k; m < MathMin(k+5, ArraySize(ratesBBTF)); m++){ // Chequear velas alrededor del ChoCH
                     if(breakerDirectionIsBullish && ratesBBTF[m].high > breakerLevelPrice) {breakerLevelBroken=true; break;}
                     if(!breakerDirectionIsBullish && ratesBBTF[m].low < breakerLevelPrice) {breakerLevelBroken=true; break;}
                 }
                 if(!breakerLevelBroken) continue;

                shiftConfirmedTime = ratesBBTF[k].time;
                break;
            }
        }


        if(shiftConfirmedTime > 0)
        {
            BreakerBlock bb;
            bb.isBullish = breakerDirectionIsBullish;
            bb.price = breakerLevelPrice;
            bb.confirmationTime = shiftConfirmedTime;
            bb.originalOBTime = failedOB.time;
            bb.qualityScore = 6.0; // Base
            bb.isMitigated = false; // Chequear mitigación después

            double liqStrength = 0;
            if(CheckIfPriceTookSignificantLiquidity(breakerLevelPrice, !failedOB.isBullish, liqStrength))
            {
                bb.qualityScore += liqStrength * 0.15; // Bonus más pequeño
            }
            
            // Chequear si el Breaker ya fue mitigado (tocado después de su confirmación)
            int confirmBarIdx = iBarShift(Symbol(), bbTF, bb.confirmationTime, true);
            if(confirmBarIdx >=0) {
                for(int m = confirmBarIdx -1; m >=0; m--) { // Velas después de la confirmación
                     if(bb.isBullish && iLow(Symbol(), bbTF, m) <= bb.price) {bb.isMitigated = true; break;}
                     if(!bb.isBullish && iHigh(Symbol(), bbTF, m) >= bb.price) {bb.isMitigated = true; break;}
                }
            }


            if(bb.qualityScore >= inpMinBBQualityForEntry && !bb.isMitigated)
            {
                int sz = ArraySize(breakerBlocks);
                if(sz < 50) { // Limitar
                   ArrayResize(breakerBlocks, sz + 1);
                   breakerBlocks[sz] = bb;
                }
            }
        }
    }
    // PrintFormat("DetectBreakerBlocks: %d BBs detectados en %s (fuente OB: %s).", ArraySize(breakerBlocks), EnumToString(bbTF), EnumToString(obSourceTF));
}


//+------------------------------------------------------------------+
//| DetectStopHunt - Detecta un barrido de liquidez (Stop Hunt)      |
//+------------------------------------------------------------------+
bool DetectStopHunt(double levelToHunt, bool isBuySideLiquidity, // true si 'levelToHunt' es un High, false si es un Low
                    datetime &outHuntCandleTime, double &outPenetrationExtremePrice, int &outHuntStrength,
                    ENUM_TIMEFRAMES timeframe = PERIOD_M5) // TF donde buscar el hunt
{
    outHuntCandleTime = 0;
    outPenetrationExtremePrice = 0;
    outHuntStrength = 0;

    double atrTF = ComputeATR(timeframe, ATRPeriod_M15); // Usar ATRPeriod_M15 como genérico
    if(atrTF <= 0) {
        // PrintFormat("DetectStopHunt: ATR inválido en %s.", EnumToString(timeframe));
        return false;
    }

    double minPenetrationPoints = atrTF * inpSH_ATR_MinPenetration;
    double maxPenetrationPoints = atrTF * inpSH_ATR_MaxPenetration;
    int reversalBarsToConfirm = inpSH_MinReversalBars;

    int barsToScan = 30; // Cuántas velas del 'timeframe' mirar hacia atrás para el hunt
    MqlRates rates[];
    if(CopyRates(Symbol(), timeframe, 0, barsToScan + reversalBarsToConfirm + 1, rates) < reversalBarsToConfirm + 5) {
        // PrintFormat("DetectStopHunt: Datos insuficientes en %s.", EnumToString(timeframe));
        return false;
    }
    ArraySetAsSeries(rates, true); // rates[0] es la vela actual (en formación)

    int penetrationCandleIndex = -1; // Índice en 'rates' de la vela que penetró
    double currentPenetrationDepth = 0;

    // Buscar la penetración más reciente y significativa
    // Iterar desde la vela cerrada más reciente (rates[1]) hacia atrás
    for(int i = 1; i <= barsToScan; i++)
    {
        double penetrationThisCandle = 0;
        double extremeThisCandle = 0;

        if(isBuySideLiquidity) // Buscando barrido de un HIGH (levelToHunt)
        {
            if(rates[i].high > levelToHunt) // Penetró el nivel
            {
                penetrationThisCandle = rates[i].high - levelToHunt;
                extremeThisCandle = rates[i].high;
            }
        }
        else // Buscando barrido de un LOW (levelToHunt)
        {
            if(rates[i].low < levelToHunt) // Penetró el nivel
            {
                penetrationThisCandle = levelToHunt - rates[i].low;
                extremeThisCandle = rates[i].low;
            }
        }

        if(penetrationThisCandle >= minPenetrationPoints && penetrationThisCandle <= maxPenetrationPoints)
        {
            // Encontrada una penetración válida. Queremos la más "fuerte" o la que mejor se revierte.
            // Por ahora, tomamos la primera válida que encontremos (la más reciente).
            penetrationCandleIndex = i;
            outPenetrationExtremePrice = extremeThisCandle;
            currentPenetrationDepth = penetrationThisCandle;
            outHuntCandleTime = rates[i].time;
            break; 
        }
    }

    if(penetrationCandleIndex == -1) return false; // No se encontró penetración válida

    // --- Confirmación de Reversión ---
    // Verificar si las 'reversalBarsToConfirm' velas SIGUIENTES a la penetración
    // (índices menores en 'rates': rates[penetrationCandleIndex-1], rates[penetrationCandleIndex-2]...)
    // cerraron de vuelta al otro lado del 'levelToHunt'.
    bool reversalConfirmedByClose = false;
    double totalReversalMagnitude = 0; // Cuánto revirtió el precio desde el extremo de la penetración

    for(int k = 1; k <= reversalBarsToConfirm; k++)
    {
        int reversalCandleIndex = penetrationCandleIndex - k;
        if(reversalCandleIndex < 0) break; // No hay suficientes velas para confirmar la reversión

        if(isBuySideLiquidity) // Penetró HIGH, buscamos cierre ABAJO del levelToHunt
        {
            if(rates[reversalCandleIndex].close < levelToHunt)
            {
                reversalConfirmedByClose = true;
            }
            // Medir reversión desde el outPenetrationExtremePrice (high del hunt) al low de la vela de reversión
            totalReversalMagnitude = MathMax(totalReversalMagnitude, outPenetrationExtremePrice - rates[reversalCandleIndex].low);
        }
        else // Penetró LOW, buscamos cierre ARRIBA del levelToHunt
        {
            if(rates[reversalCandleIndex].close > levelToHunt)
            {
                reversalConfirmedByClose = true;
            }
            totalReversalMagnitude = MathMax(totalReversalMagnitude, rates[reversalCandleIndex].high - outPenetrationExtremePrice);
        }
        if(reversalConfirmedByClose) break; // Confirmado por cierre
    }
    
    // Verificar fuerza de la reversión
    bool strongReversalMagnitude = false;
    if(currentPenetrationDepth > 0 && (totalReversalMagnitude / currentPenetrationDepth * 100.0) >= inpSH_ReversalStrengthPercent)
    {
        strongReversalMagnitude = true;
    }

    if(!reversalConfirmedByClose || !strongReversalMagnitude) return false; // No hubo reversión confirmada y fuerte


    // --- Calcular Fuerza del Hunt ---
    outHuntStrength = 5; // Base
    if (totalReversalMagnitude > atrTF * 1.2) outHuntStrength += 2; // Reversión fuerte en términos de ATR
    if (currentPenetrationDepth < atrTF * 0.5) outHuntStrength +=1; // Penetración sutil (a veces más engañosa)
    
    // Volumen: Comprobar si el volumen aumentó en la reversión comparado con la penetración
    long penetrationVol = (long)rates[penetrationCandleIndex].tick_volume;
    double avgReversalVol = 0;
    long reversalVolSum = 0;
    int volCount = 0;
    for(int k=1; k <= reversalBarsToConfirm; k++) {
        int revIdx = penetrationCandleIndex - k;
        if(revIdx < 0) break;
        reversalVolSum += (long)rates[revIdx].tick_volume;
        volCount++;
    }
    if(volCount>0) avgReversalVol = (double)reversalVolSum / volCount;
    if(penetrationVol > 0 && avgReversalVol > penetrationVol * inpSH_VolumeDivergenceMultiplier) outHuntStrength += 3;

    outHuntStrength = MathMax(1, MathMin(outHuntStrength, 10)); // Limitar 1-10
    
    /*
    PrintFormat("DetectStopHunt: Hunt %s en %s. Nivel:%.5f, Penetration:%.5f (Ext:%.5f), Reversion:%.5f. Fuerza: %d. HuntTime: %s",
                reversalConfirmedByClose && strongReversalMagnitude ? "CONFIRMADO":"FALLIDO",
                EnumToString(timeframe), levelToHunt, currentPenetrationDepth, outPenetrationExtremePrice, totalReversalMagnitude,
                outHuntStrength, TimeToString(outHuntCandleTime));
    */
    return true;
}

//+------------------------------------------------------------------+
//| Funciones de Bias y Estructura de Mercado                        |
//+------------------------------------------------------------------+

// --- ComputeD1Bias ---
void ComputeD1Bias()
{
   double adxVal, plusDiVal, minusDiVal;
   // Usar vela cerrada (shift=1)
   if(!GetADXValues(Symbol(), PERIOD_D1, 14, 1, adxVal, plusDiVal, minusDiVal))
   {
      // Mantener el sesgo anterior si falla la lectura
      // Print("ComputeD1Bias: Fallo ADX en D1. Se mantiene sesgo anterior.");
      return;
   }

   double ema20 = GetEMAValue(Symbol(), PERIOD_D1, 20, 1);
   double ema50 = GetEMAValue(Symbol(), PERIOD_D1, 50, 1);
   if (ema20 == 0.0 || ema50 == 0.0) {
      // Print("ComputeD1Bias: Fallo EMAs en D1. Se mantiene sesgo anterior.");
      return; // No calcular si EMAs fallan
   }
   double closePrice = iClose(Symbol(), PERIOD_D1, 1); // Vela cerrada

   bool trendCondition = (adxVal >= 20.0); // Tendencia si ADX >= 20
   bool bullishSignal = (plusDiVal > minusDiVal && closePrice > ema20 && ema20 > ema50);
   bool bearishSignal = (minusDiVal > plusDiVal && closePrice < ema20 && ema20 < ema50);

   if(trendCondition && bullishSignal) g_D1BiasIsBullish = true;
   else if(trendCondition && bearishSignal) g_D1BiasIsBullish = false;
   // else: Si no hay tendencia clara o señales mixtas, MANTENER el sesgo D1 anterior.
   // PrintFormat("ComputeD1Bias: D1 Bias es %s (ADX:%.1f, +DI:%.1f, -DI:%.1f, C:%.5f, E20:%.5f, E50:%.5f)",
   //             g_D1BiasIsBullish ? "BULLISH" : "BEARISH", adxVal, plusDiVal, minusDiVal, closePrice, ema20, ema50);
}

// --- ComputeH4Bias ---
void ComputeH4Bias()
{
   double adxVal, plusDiVal, minusDiVal;
   if(!GetADXValues(Symbol(), PERIOD_H4, 14, 1, adxVal, plusDiVal, minusDiVal))
   {
      // Print("ComputeH4Bias: Fallo ADX en H4. Se mantiene sesgo anterior.");
      return;
   }

   double ema20 = GetEMAValue(Symbol(), PERIOD_H4, 20, 1);
   double ema50 = GetEMAValue(Symbol(), PERIOD_H4, 50, 1);
   if (ema20 == 0.0 || ema50 == 0.0) {
      // Print("ComputeH4Bias: Fallo EMAs en H4. Se mantiene sesgo anterior.");
      return;
   }
   double closePrice = iClose(Symbol(), PERIOD_H4, 1);

   bool trendCondition = (adxVal >= 20.0);
   bool bullishSignal = (plusDiVal > minusDiVal && closePrice > ema20 && ema20 > ema50);
   bool bearishSignal = (minusDiVal > plusDiVal && closePrice < ema20 && ema20 < ema50);

   if(trendCondition && bullishSignal) g_H4BiasIsBullish = true;
   else if(trendCondition && bearishSignal) g_H4BiasIsBullish = false;
   // else: Mantener sesgo H4 anterior.
   // PrintFormat("ComputeH4Bias: H4 Bias es %s", g_H4BiasIsBullish ? "BULLISH" : "BEARISH");
}

// --- DetectMarketStructure (Unificada) ---
MarketStructureState DetectMarketStructure(ENUM_TIMEFRAMES tf, int lookbackBars, int pivotStrength = 2)
{
    int totalBarsTF = iBars(Symbol(), tf);
    if(totalBarsTF < lookbackBars + pivotStrength * 2 + 5) return MSS_UNKNOWN; // Necesitamos suficientes barras

    MqlRates rates[];
    // Copiar suficientes barras para el lookback y la detección de fractales
    int barsToCopy = MathMin(totalBarsTF, lookbackBars + pivotStrength * 4 + 10); // Un margen extra
    if(CopyRates(Symbol(), tf, 0, barsToCopy, rates) != barsToCopy) return MSS_UNKNOWN;
    ArraySetAsSeries(rates, true); // rates[0] es la vela actual

    SwingPoint swings[];
    ArrayResize(swings,0);
    int swingsToAnalyze = 6; // Analizar los últimos 6 swings para estructura

    // Detectar los swings más recientes (fractales)
    for(int i = pivotStrength; i < barsToCopy - pivotStrength && ArraySize(swings) < swingsToAnalyze * 2 ; i++)
    {
        bool isHigh = true, isLow = true;
        for(int j = 1; j <= pivotStrength; j++) {
            if(rates[i-j].high > rates[i].high || rates[i+j].high > rates[i].high) isHigh = false;
            if(rates[i-j].low < rates[i].low || rates[i+j].low < rates[i].low) isLow = false;
            if(!isHigh && !isLow) break;
        }
        if(isHigh) {
            SwingPoint sp = {rates[i].time, rates[i].high, true};
            int sz=ArraySize(swings); ArrayResize(swings, sz+1); swings[sz]=sp;
            i += pivotStrength -1; // Saltar barras dentro del fractal
        } else if(isLow) {
            SwingPoint sp = {rates[i].time, rates[i].low, false};
            int sz=ArraySize(swings); ArrayResize(swings, sz+1); swings[sz]=sp;
            i += pivotStrength-1;
        }
    }
    
    // Asegurarse de que los swings estén ordenados por tiempo (más reciente primero)
    // El bucle anterior ya los añade en orden cronológico inverso (rates[i] es más antiguo que rates[i-1])
    // pero como los guardamos en 'swings' y usamos ArraySetAsSeries(rates, true),
    // el primer swing detectado (el más antiguo en el rango) estará al final del array 'swings'.
    // Necesitamos revertir el orden de 'swings' para que el más reciente sea swings[0].
    // O, más fácil, leer 'swings' desde el final si no lo revertimos.

    // Simple sort (más reciente primero) si no se hizo bien arriba
    if(ArraySize(swings) > 1) {
      for(int i=0; i<ArraySize(swings)-1; i++) {
         for(int j=0; j<ArraySize(swings)-1-i; j++) {
            if(swings[j].time < swings[j+1].time) {
               SwingPoint temp = swings[j];
               swings[j] = swings[j+1];
               swings[j+1] = temp;
            }
         }
      }
    }


    if(ArraySize(swings) < 4) return MSS_RANGE; // Necesitamos al menos 2 highs y 2 lows

    // Analizar los últimos 4 swings para la estructura básica HH/HL o LH/LL
    // swings[0] = Más reciente (P4)
    // swings[1] = P3
    // swings[2] = P2
    // swings[3] = Más antiguo (P1)

    SwingPoint p4 = swings[0];
    SwingPoint p3 = swings[1];
    SwingPoint p2 = swings[2];
    SwingPoint p1 = swings[3];

    // Verificar alternancia H-L-H-L o L-H-L-H (simplificado)
    if(p4.isHigh == p3.isHigh || p3.isHigh == p2.isHigh || p2.isHigh == p1.isHigh) return MSS_RANGE; // No alternante

    bool isBullish = false;
    bool isBearish = false;

    if(p4.isHigh && !p3.isHigh && p2.isHigh && !p1.isHigh) // Secuencia H-L-H-L (más reciente es p4 High)
    {
        if(p4.price > p2.price && p3.price > p1.price) isBullish = true; // HH y HL
        else if (p4.price < p2.price && p3.price < p1.price) isBearish = true; // Podría ser un ChoCH bajista formándose
    }
    else if(!p4.isHigh && p3.isHigh && !p2.isHigh && p1.isHigh) // Secuencia L-H-L-H (más reciente es p4 Low)
    {
        if(p3.price < p1.price && p4.price < p2.price) isBearish = true; // LH y LL
        else if (p3.price > p1.price && p4.price > p2.price) isBullish = true; // Podría ser un ChoCH alcista formándose
    }

    if(isBullish) return MSS_BULLISH;
    if(isBearish) return MSS_BEARISH;
    return MSS_RANGE; // Si no es claramente alcista o bajista
}

// --- DetectBOS (Break of Structure) ---
// barIndexShift: 0 para vela actual, 1 para última cerrada, etc.
// isBullishAttempt: true si buscamos un BOS alcista (ruptura de un SH previo)
bool DetectBOS(ENUM_TIMEFRAMES tf, int barIndexShift, bool isBullishAttempt, int lookbackSwings = 15, int pivotStrength = 2)
{
    MqlRates rates[];
    int barsToCopy = MathMax(lookbackSwings * (pivotStrength +1), barIndexShift + pivotStrength*2 + 20); //Suficientes barras
    if(CopyRates(Symbol(), tf, 0, barsToCopy, rates) != barsToCopy) return false;
    ArraySetAsSeries(rates, true);

    if(barIndexShift < 0 || barIndexShift >= ArraySize(rates)) return false; // Shift inválido
    datetime breakCandleTime = rates[barIndexShift].time; // Vela que se supone rompe la estructura

    // 1. Encontrar el ÚLTIMO swing HIGH relevante ANTERIOR a la vela de ruptura (si buscamos BOS alcista)
    // O el ÚLTIMO swing LOW relevante ANTERIOR (si buscamos BOS bajista)
    double relevantSwingLevel = 0;
    datetime relevantSwingTime = 0;

    // Buscar swings hacia atrás desde la vela ANTERIOR a la de ruptura
    for(int i = barIndexShift + pivotStrength + 1; i < ArraySize(rates) - pivotStrength; i++)
    {
        if(ArraySize(rates) < i + pivotStrength +1 ) break; // Asegurar índices para fractal

        bool isSwing = true;
        double currentLevel = 0;
        bool isCurrentSwingHigh = false;

        if(isBullishAttempt) { // Buscamos romper un HIGH previo
            currentLevel = rates[i].high;
            isCurrentSwingHigh = true;
            for(int j=1; j<=pivotStrength; j++) if(rates[i-j].high > currentLevel || rates[i+j].high > currentLevel) {isSwing=false; break;}
        } else { // Buscamos romper un LOW previo
            currentLevel = rates[i].low;
            isCurrentSwingHigh = false;
            for(int j=1; j<=pivotStrength; j++) if(rates[i-j].low < currentLevel || rates[i+j].low < currentLevel) {isSwing=false; break;}
        }

        if(isSwing) {
            // Este es un swing. ¿Es el correcto para un BOS?
            // Para BOS Alcista, necesitamos romper un Swing High.
            // Para BOS Bajista, necesitamos romper un Swing Low.
            if((isBullishAttempt && isCurrentSwingHigh) || (!isBullishAttempt && !isCurrentSwingHigh)) {
                 // Ahora, este swing debe estar precedido por un pullback.
                 // Buscamos el ÚLTIMO SH (para BOS alcista) o SL (para BOS bajista) que formó parte de la tendencia previa.
                 // Simplificación: tomamos el swing más reciente del tipo correcto.
                 if(relevantSwingTime == 0 || rates[i].time > relevantSwingTime) { // Queremos el más RECIENTE de estos swings relevantes
                     relevantSwingLevel = currentLevel;
                     relevantSwingTime = rates[i].time;
                 }
            }
            i += pivotStrength -1; // Saltar
        }
        if(i > barIndexShift + lookbackSwings * 2 && relevantSwingTime > 0) break; // No buscar demasiado atrás si ya encontramos uno
    }
    
    if(relevantSwingLevel == 0) return false; // No se encontró swing relevante

    // 2. Verificar si la vela en 'barIndexShift' rompió ese 'relevantSwingLevel'
    if(isBullishAttempt) { // BOS Alcista: cierre de la vela de ruptura por encima del relevantSwingLevel (que era un SH)
        return (rates[barIndexShift].close > relevantSwingLevel && rates[barIndexShift].high > relevantSwingLevel);
    } else { // BOS Bajista: cierre de la vela de ruptura por debajo del relevantSwingLevel (que era un SL)
        return (rates[barIndexShift].close < relevantSwingLevel && rates[barIndexShift].low < relevantSwingLevel);
    }
}

// --- DetectChoCH (Change of Character) ---
// isBullishAttempt: true si buscamos un ChoCH ALCISTA (ruptura de un LH en una tendencia bajista previa)
bool DetectChoCH(ENUM_TIMEFRAMES tf, int barIndexShift, bool isBullishAttempt, int lookbackSwings = 15, int pivotStrength = 2)
{
    MqlRates rates[];
    int barsToCopy = MathMax(lookbackSwings * (pivotStrength +1) * 2, barIndexShift + pivotStrength*2 + 30); // Más barras para contexto de tendencia previa
    if(CopyRates(Symbol(), tf, 0, barsToCopy, rates) != barsToCopy) return false;
    ArraySetAsSeries(rates, true);

    if(barIndexShift < 0 || barIndexShift >= ArraySize(rates)) return false;
    datetime breakCandleTime = rates[barIndexShift].time;

    // 1. Identificar la tendencia PREVIA al supuesto ChoCH.
    // Si buscamos ChoCH ALCISTA, la tendencia previa debe ser BAJISTA (buscamos romper el ÚLTIMO Lower High - LH).
    // Si buscamos ChoCH BAJISTA, la tendencia previa debe ser ALCISTA (buscamos romper el ÚLTIMO Higher Low - HL).

    double relevantSwingToBreak = 0;
    datetime relevantSwingToBreakTime = 0;

    // Buscar swings hacia atrás desde la vela ANTERIOR a la de ruptura
    for(int i = barIndexShift + pivotStrength + 1; i < ArraySize(rates) - pivotStrength; i++)
    {
        if(ArraySize(rates) < i + pivotStrength +1 ) break;

        bool isSwing = true;
        double currentLevel = 0;
        bool isCurrentSwingHigh = false;

        // Determinar si es un swing high o low
        bool isHighCand = true, isLowCand = true;
        for(int j=1; j<=pivotStrength; j++) {
            if(rates[i-j].high > rates[i].high || rates[i+j].high > rates[i].high) isHighCand = false;
            if(rates[i-j].low < rates[i].low || rates[i+j].low < rates[i].low) isLowCand = false;
        }

        if(isHighCand) {
            isCurrentSwingHigh = true;
            currentLevel = rates[i].high;
        } else if (isLowCand) {
            isCurrentSwingHigh = false;
            currentLevel = rates[i].low;
        } else continue; // No es un fractal claro

        // Para ChoCH ALCISTA (isBullishAttempt = true), buscamos romper el último LOWER HIGH (isCurrentSwingHigh=true).
        // Para ChoCH BAJISTA (isBullishAttempt = false), buscamos romper el último HIGHER LOW (isCurrentSwingHigh=false).
        if((isBullishAttempt && isCurrentSwingHigh) || (!isBullishAttempt && !isCurrentSwingHigh))
        {
            // Este es un candidato a ser el swing que, si se rompe, indica un ChoCH.
            // Queremos el más RECIENTE de estos.
            if(relevantSwingToBreakTime == 0 || rates[i].time > relevantSwingToBreakTime) {
                relevantSwingToBreak = currentLevel;
                relevantSwingToBreakTime = rates[i].time;
            }
        }
        i += pivotStrength -1; // Saltar
        if(i > barIndexShift + lookbackSwings * 2 && relevantSwingToBreakTime > 0) break;
    }

    if(relevantSwingToBreak == 0) return false; // No se encontró el swing relevante de la estructura previa

    // 2. Verificar si la vela en 'barIndexShift' rompió ese 'relevantSwingToBreak'
    if(isBullishAttempt) { // ChoCH Alcista: vela rompe el LH previo
        return (rates[barIndexShift].close > relevantSwingToBreak && rates[barIndexShift].high > relevantSwingToBreak);
    } else { // ChoCH Bajista: vela rompe el HL previo
        return (rates[barIndexShift].close < relevantSwingToBreak && rates[barIndexShift].low < relevantSwingToBreak);
    }
}


//+------------------------------------------------------------------+
//| Funciones de Narrativa de Precios y Desviación Estándar          |
//+------------------------------------------------------------------+
bool CalculateStandardDeviationProjections(datetime rangeDataStartTime, datetime rangeDataEndTime, ENUM_TIMEFRAMES dataTF, int candlesForCalculation,
                                           double &outMean, double &outStdDev,
                                           double &outProjP1, double &outProjP2, double &outProjP2_5, double &outProjP4,
                                           double &outProjM1, double &outProjM2, double &outProjM2_5, double &outProjM4)
{
    // Implementación de CalculateStandardDeviationProjections (ya proporcionada en la Sección 2.1)
    // ... Copiar la función CalculateStandardDeviationProjections completa aquí ...
    outMean=0; outStdDev=0; outProjP1=0; outProjP2=0; outProjP2_5=0; outProjP4=0; outProjM1=0; outProjM2=0; outProjM2_5=0; outProjM4=0;
    MqlRates ratesToCalc[];
    int barsCopied = 0;

    if(candlesForCalculation > 0) { // Usar un número fijo de velas terminando en rangeDataEndTime
        int shift = iBarShift(Symbol(), dataTF, rangeDataEndTime, true);
        if(shift < 0) shift = 0; // Si endTime es futuro, empezar desde la actual
        barsCopied = CopyRates(Symbol(), dataTF, shift, candlesForCalculation, ratesToCalc);
    } else { // Usar el rango de tiempo rangeDataStartTime - rangeDataEndTime
        barsCopied = CopyRates(Symbol(), dataTF, rangeDataStartTime, rangeDataEndTime, ratesToCalc);
    }

    if(barsCopied <= 1) {
        // PrintFormat("StdDevCalc: Insufficient bars (%d) in %s for range %s to %s or %d candles", barsCopied, EnumToString(dataTF), TimeToString(rangeDataStartTime), TimeToString(rangeDataEndTime), candlesForCalculation);
        return false;
    }
    // ArraySetAsSeries(ratesToCalc, true); // CopyRates ya devuelve en orden cronológico (0 es más antiguo)

    double closePrices[]; ArrayResize(closePrices, barsCopied);
    for(int i=0; i<barsCopied; i++) closePrices[i] = ratesToCalc[i].close;

    double sum = 0; for(int i=0; i<barsCopied; i++) sum += closePrices[i];
    outMean = sum / barsCopied;

    double sumSqDiff = 0; for(int i=0; i<barsCopied; i++) sumSqDiff += MathPow(closePrices[i] - outMean, 2);
    if(barsCopied == 0) return false; // Evitar división por cero
    double variance = sumSqDiff / barsCopied; // Varianza de la Población
    outStdDev = MathSqrt(variance);

    if(outStdDev == 0 || outStdDev < SymbolInfoDouble(Symbol(), SYMBOL_POINT)) { // DE muy pequeña o cero
        // PrintFormat("StdDevCalc: StdDev is zero or too small (%.7f) for meaningful projections. Mean: %.5f", outStdDev, outMean);
        // Proyecciones serán iguales a la media si DE es 0, lo que no es útil.
        outProjP1=outMean; outProjP2=outMean; outProjP2_5=outMean; outProjP4=outMean;
        outProjM1=outMean; outProjM2=outMean; outProjM2_5=outMean; outProjM4=outMean;
        return true; // Retornar true pero proyecciones no son expansivas
    }

    outProjP1 = outMean + (1.0 * outStdDev); outProjP2 = outMean + (2.0 * outStdDev);
    outProjP2_5 = outMean + (2.5 * outStdDev); outProjP4 = outMean + (4.0 * outStdDev);
    outProjM1 = outMean - (1.0 * outStdDev); outProjM2 = outMean - (2.0 * outStdDev);
    outProjM2_5 = outMean - (2.5 * outStdDev); outProjM4 = outMean - (4.0 * outStdDev);
    return true;
}

void UpdateAndStoreStdDevProjections(bool forceRecalculate = false)
{
    // Implementación de UpdateAndStoreStdDevProjections (ya proporcionada en la Sección 2.1)
    // ... Copiar la función UpdateAndStoreStdDevProjections completa aquí ...
    if(!inpEnableStdDevProjections){ g_stdDevProjections.calculationTime = 0; return; }
    datetime now = TimeCurrent();
    if(!forceRecalculate && g_stdDevProjections.calculationTime != 0 && (now - g_stdDevProjections.calculationTime) < inpStdDev_RecalculateMinutes * 60) return;

    datetime endTimeForRange = iTime(Symbol(), inpStdDev_RangeDataTF, 1); // Última vela CERRADA del TF de datos
    datetime startTimeForRange = iTime(Symbol(), inpStdDev_RangeDataTF, inpStdDev_ProjectionPeriod); // Inicio del rango de datos

    bool success = CalculateStandardDeviationProjections(
        startTimeForRange, endTimeForRange, inpStdDev_RangeDataTF, inpStdDev_ProjectionPeriod, // Pasamos el número de velas también
        g_stdDevProjections.mean, g_stdDevProjections.stdDev,
        g_stdDevProjections.projPlus1, g_stdDevProjections.projPlus2, g_stdDevProjections.projPlus2_5, g_stdDevProjections.projPlus4,
        g_stdDevProjections.projMinus1, g_stdDevProjections.projMinus2, g_stdDevProjections.projMinus2_5, g_stdDevProjections.projMinus4
    );

    if(success){
        g_stdDevProjections.calculationTime = now;
        g_stdDevProjections.rangeStartTimeUsed = startTimeForRange;
        g_stdDevProjections.rangeEndTimeUsed = endTimeForRange;
        g_stdDevProjections.rangeTimeframeUsed = inpStdDev_RangeDataTF;
        // PrintFormat("StdDev Projections updated globally at %s. Mean: %.5f, StdDev: %.5f", TimeToString(now), g_stdDevProjections.mean, g_stdDevProjections.stdDev);
    } else {
        g_stdDevProjections.calculationTime = 0;
        // PrintFormat("Failed to update StdDev Projections globally at %s.", TimeToString(now));
    }
}

//+------------------------------------------------------------------+
//| UpdatePriceNarrativeContext - Actualiza el contexto global de    |
//| la narrativa de precios (ICT Model 2022).                        |
//| Llamada en OnTick() después de las detecciones principales.      |
//+------------------------------------------------------------------+
void UpdatePriceNarrativeContext()
{
    // Variables para almacenar los resultados de las comprobaciones
    datetime sweepOccurredAtTime = 0;
    double sweptLiquidityLevel = 0;
    bool   buySideLiquiditySwept = false;
    bool   significantSweepFound = CheckIfSignificantLiquidityWasSwept(
                                        inpNarrative_HTF,                   // Timeframe para la relevancia de la liquidez barrida (ej. H1)
                                        inpNarrative_LookbackBarsHTF,       // Cuán atrás buscar la formación de la liquidez
                                        inpMinHuntStrengthForNarrative,     // Fuerza mínima del hunt para considerarlo narrativo
                                        sweepOccurredAtTime,
                                        sweptLiquidityLevel,
                                        buySideLiquiditySwept
                                    );

    datetime fvgFilledAtTime = 0;
    double   htfFVGStart = 0;
    double   htfFVGEnd = 0;
    bool     htfFVGWasBullish = false;
    bool     significantHTFFVGFilled = CheckIfHTFFVGFilled(
                                        inpNarrative_HTF,                   // Timeframe del FVG HTF
                                        inpNarrative_LookbackBarsHTF,       // Cuán atrás buscar el FVG y su llenado
                                        inpNarrative_MinFVGSizePipsHTF,     // Tamaño mínimo del FVG HTF
                                        fvgFilledAtTime,
                                        htfFVGStart,
                                        htfFVGEnd,
                                        htfFVGWasBullish
                                    );

    PriceNarrativeContext previousNarrative = g_priceNarrative; // Guardar narrativa anterior para detectar cambios

    // Lógica de Priorización y Actualización de la Narrativa Global
    // Un barrido de liquidez reciente suele tener más peso inmediato que un llenado de FVG,
    // a menos que el llenado del FVG sea más reciente que el barrido.

    if (significantSweepFound && significantHTFFVGFilled)
    {
        // Ambos eventos ocurrieron, el más reciente domina la narrativa de "re-pricing"
        if (sweepOccurredAtTime > fvgFilledAtTime)
        {
            g_priceNarrative = NARRATIVE_REPRICING_AFTER_SWEEP;
            g_lastSignificantSweepTime_Narrative = sweepOccurredAtTime;
            g_lastSignificantSweepLevel_Narrative = sweptLiquidityLevel;
            g_lastSignificantSweepWasBuySide_Narrative = buySideLiquiditySwept;
            // Resetear el FVG si el sweep es más reciente y domina
            g_lastHTFFVGFillTime_Narrative = 0;
        }
        else // FVG fill es más reciente o igual (dar prioridad al FVG fill si son iguales)
        {
            g_priceNarrative = NARRATIVE_REPRICING_AFTER_HTF_FVG_FILL;
            g_lastHTFFVGFillTime_Narrative = fvgFilledAtTime;
            g_lastHTFFVGFillLevelStart_Narrative = htfFVGStart;
            g_lastHTFFVGFillLevelEnd_Narrative = htfFVGEnd;
            g_lastHTFFVGFillWasBullish_Narrative = htfFVGWasBullish;
            // Resetear el sweep si el FVG fill es más reciente y domina
            g_lastSignificantSweepTime_Narrative = 0;
        }
    }
    else if (significantSweepFound) // Solo se encontró un barrido significativo
    {
        g_priceNarrative = NARRATIVE_REPRICING_AFTER_SWEEP;
        g_lastSignificantSweepTime_Narrative = sweepOccurredAtTime;
        g_lastSignificantSweepLevel_Narrative = sweptLiquidityLevel;
        g_lastSignificantSweepWasBuySide_Narrative = buySideLiquiditySwept;
        g_lastHTFFVGFillTime_Narrative = 0; // No hay FVG fill activo
    }
    else if (significantHTFFVGFilled) // Solo se encontró un llenado de FVG HTF significativo
    {
        g_priceNarrative = NARRATIVE_REPRICING_AFTER_HTF_FVG_FILL;
        g_lastHTFFVGFillTime_Narrative = fvgFilledAtTime;
        g_lastHTFFVGFillLevelStart_Narrative = htfFVGStart;
        g_lastHTFFVGFillLevelEnd_Narrative = htfFVGEnd;
        g_lastHTFFVGFillWasBullish_Narrative = htfFVGWasBullish;
        g_lastSignificantSweepTime_Narrative = 0; // No hay sweep activo
    }
    else // No se encontró ningún evento narrativo reciente significativo
    {
        // Si no estamos en re-pricing por un evento reciente, y no ha habido un evento que mantenga el estado,
        // el estado por defecto es buscar liquidez o desconocido.
        // La lógica de timeout se aplica para salir de los estados de re-pricing.
    }

    // Lógica de Timeout para salir del estado de "Re-pricing"
    datetime currentTime = TimeCurrent();
    long repricingTimeoutSeconds = (long)inpNarrative_RepricingDurationBarsM5 * PeriodSeconds(inpOB_DetectionTF); // Usar TF del OB para timeout

    if(g_priceNarrative == NARRATIVE_REPRICING_AFTER_SWEEP &&
       g_lastSignificantSweepTime_Narrative > 0 &&
       (currentTime - g_lastSignificantSweepTime_Narrative) > repricingTimeoutSeconds)
    {
        // PrintFormat("UpdatePriceNarrativeContext: Timeout de re-pricing post-SWEEP (Sweep a las %s). Volviendo a SEEKING_LIQUIDITY.", TimeToString(g_lastSignificantSweepTime_Narrative));
        g_priceNarrative = NARRATIVE_SEEKING_LIQUIDITY;
        g_lastSignificantSweepTime_Narrative = 0; // Resetear para que no se quede "pegado"
    }
    else if(g_priceNarrative == NARRATIVE_REPRICING_AFTER_HTF_FVG_FILL &&
            g_lastHTFFVGFillTime_Narrative > 0 &&
            (currentTime - g_lastHTFFVGFillTime_Narrative) > repricingTimeoutSeconds)
    {
        // PrintFormat("UpdatePriceNarrativeContext: Timeout de re-pricing post-FVG FILL (Fill a las %s). Volviendo a SEEKING_LIQUIDITY.", TimeToString(g_lastHTFFVGFillTime_Narrative));
        g_priceNarrative = NARRATIVE_SEEKING_LIQUIDITY;
        g_lastHTFFVGFillTime_Narrative = 0; // Resetear
    }

    // Si no hay un evento activo de re-pricing (ya sea porque no ocurrió o porque timeouteó)
    if(g_priceNarrative != NARRATIVE_REPRICING_AFTER_SWEEP && g_priceNarrative != NARRATIVE_REPRICING_AFTER_HTF_FVG_FILL)
    {
        // Si no hay eventos dominantes, el mercado está probablemente "buscando liquidez" o en un estado neutro/desconocido.
        // Este estado es el base hasta que ocurra un evento narrativo.
        g_priceNarrative = NARRATIVE_SEEKING_LIQUIDITY; // O NARRATIVE_UNKNOWN si el sesgo no es claro.
    }

    // Loguear solo si la narrativa cambió
    // if(previousNarrative != g_priceNarrative && (currentTime - g_lastFullUpdateTime < 2) ) // Loguear si es reciente el full update
    // {
    //    PrintFormat("UpdatePriceNarrativeContext: Narrativa de Precio -> %s. (SweepTime: %s, FVGTime: %s)",
    //                EnumToString(g_priceNarrative),
    //                TimeToString(g_lastSignificantSweepTime_Narrative),
    //                TimeToString(g_lastHTFFVGFillTime_Narrative));
    // }
}


//+------------------------------------------------------------------+
//| Funciones de Narrativa de Precios (Continuación)                 |
//+------------------------------------------------------------------+

// Implementación de CheckIfSignificantLiquidityWasSwept (ya proporcionada y modificada en la Sección 1.1)
bool CheckIfSignificantLiquidityWasSwept(ENUM_TIMEFRAMES checkTF, int lookbackBarsHTF, int minHuntStrengthNarr,
                                         datetime &outSweepTimeDetected, double &outSweepLevel, bool &outWasBuysideSweep)
{
    // Esta función itera sobre zonas de liquidez EXTERNA y de alta fuerza
    // y usa DetectStopHunt para ver si fueron barridas recientemente.
    // 'lookbackBarsHTF' se usa para determinar cuán atrás buscar la *formación* de la liquidez,
    // y el barrido debe ser "reciente" en un TF inferior (M5).
    
    outSweepTimeDetected = 0; outSweepLevel = 0; outWasBuysideSweep = false;
    datetime huntOccurredTime = 0;
    double penetrationPrice = 0;
    int huntStrengthFound = 0;

    // Ordenar por fuerza para chequear las más importantes primero, luego por tiempo para las más recientes de esas.
    // O simplemente iterar y filtrar.
    // ArraySort(liquidityZones, WHOLE_ARRAY, offsetof(LiquidityZone, strength), MODE_DESCEND);

    for(int i = 0; i < ArraySize(liquidityZones); i++)
    {
        // Considerar solo liquidez externa o EQH/EQL muy fuertes para narrativa de barrido principal
        if(liquidityZones[i].scope != LIQUIDITY_SCOPE_EXTERNAL && liquidityZones[i].strength < inpLiq_StrengthEQH_EQL_Clean - 0.5)
            continue;
        
        // La zona de liquidez debe ser relativamente reciente (ej. formada en las últimas 'lookbackBarsHTF' del checkTF)
        // Esto es para evitar considerar barridos de liquidez muy antigua que pueden no ser relevantes para la narrativa actual.
        if( (iTime(Symbol(), checkTF, 0) - liquidityZones[i].time) > (long)lookbackBarsHTF * PeriodSeconds(checkTF) ) {
             // Si la zona se formó hace mucho, pero el barrido es reciente, aún podría ser válido.
             // El chequeo de "reciente" se hace mejor sobre el tiempo del barrido.
        }


        if(DetectStopHunt(liquidityZones[i].price, liquidityZones[i].isBuySide,
                           huntOccurredTime, penetrationPrice, huntStrengthFound, PERIOD_M5)) // Hunt en M5
        {
            if(huntStrengthFound >= minHuntStrengthNarr)
            {
                // Verificar si el barrido (huntOccurredTime) es suficientemente reciente
                // ej. dentro de las últimas X velas del checkTF o un timeframe fijo
                long lookbackSecondsForSweep = (long)inpNarrative_RepricingDurationBarsM5 * PeriodSeconds(PERIOD_M5) * 2; // Doble del repricing
                if ((TimeCurrent() - huntOccurredTime) <= lookbackSecondsForSweep)
                {
                    outSweepTimeDetected = huntOccurredTime;
                    outSweepLevel = liquidityZones[i].price; // Nivel de la liquidez barrida
                    outWasBuysideSweep = liquidityZones[i].isBuySide;
                    // PrintFormat("CheckIfSignificantLiquidityWasSwept: Barrido Signif. de '%s' (%.5f) detectado en %s. Fuerza: %d",
                    //             liquidityZones[i].type, outSweepLevel, TimeToString(outSweepTimeDetected), huntStrengthFound);
                    return true;
                }
            }
        }
         if(i>30 && outSweepTimeDetected == 0) break; // Optimización: si no encontramos nada en las primeras 30 zonas fuertes
    }
    return false;
}

// Implementación de CheckIfHTFFVGFilled (ya proporcionada y modificada en la Sección 1.1)
bool CheckIfHTFFVGFilled(ENUM_TIMEFRAMES checkTF, int lookbackBarsHTF, double minFVGSizePipsHTF,
                         datetime &outFillTime, double &outFVGStartPrice, double &outFVGEndPrice, bool &outWasBullishFVG)
{
    // Esta función busca FVGs en checkTF y verifica si han sido llenados recientemente.
    outFillTime = 0; outFVGStartPrice = 0; outFVGEndPrice = 0; outWasBullishFVG = false;

    MqlRates ratesHTF[];
    int barsToSearchFVG = MathMin(iBars(Symbol(),checkTF)-1, lookbackBarsHTF + 5);
    if(barsToSearchFVG < 3) return false;
    if(CopyRates(Symbol(), checkTF, 0, barsToSearchFVG, ratesHTF) != barsToSearchFVG) return false;
    ArraySetAsSeries(ratesHTF, true);

    double point = SymbolInfoDouble(Symbol(),SYMBOL_POINT);
    double minFVGSizePoints = minFVGSizePipsHTF * point * ((Digits() % 2 == 1 && point < 0.001) ? 10:1);
    if(minFVGSizePoints <=0 && point > 0) minFVGSizePoints = minFVGSizePipsHTF * point;
    else if(minFVGSizePoints <=0) minFVGSizePoints = minFVGSizePipsHTF * 0.0001;


    for(int i = 1; i < barsToSearchFVG - 1; i++) // i es la vela central del posible FVG
    {
        double c0_H = ratesHTF[i+1].high; double c0_L = ratesHTF[i+1].low;
        double c2_H = ratesHTF[i-1].high; double c2_L = ratesHTF[i-1].low;
        datetime fvgFormTimeCandle1 = ratesHTF[i+1].time; // Tiempo de la primera vela

        double fvgS=0, fvgE=0; bool isBull=false;

        if(c0_H < c2_L && (c2_L - c0_H) >= minFVGSizePoints) { // Bullish FVG
            fvgS = c0_H; fvgE = c2_L; isBull = true;
        } else if(c0_L > c2_H && (c0_L - c2_H) >= minFVGSizePoints) { // Bearish FVG
            fvgS = c2_H; fvgE = c0_L; isBull = false;
        } else continue;

        // Verificar si este FVG fue llenado por velas MÁS RECIENTES que su formación (posteriores a rates[i-1])
        for(int k = i - 2; k >= 0; k--) // Velas posteriores a la formación del FVG
        {
            bool filledThisCandle = false;
            if(isBull) { // Bullish FVG (precio debe bajar para llenarlo)
                if(ratesHTF[k].low <= fvgS) filledThisCandle = true; // Llenado completo (toca el inicio)
            } else { // Bearish FVG (precio debe subir para llenarlo)
                if(ratesHTF[k].high >= fvgE) filledThisCandle = true; // Llenado completo (toca el inicio)
            }

            if(filledThisCandle)
            {
                outFillTime = ratesHTF[k].time; // Tiempo de la vela que llenó
                outFVGStartPrice = fvgS; outFVGEndPrice = fvgE; outWasBullishFVG = isBull;
                // PrintFormat("CheckIfHTFFVGFilled: FVG %s en %s (%.5f-%.5f, Formado por vela1: %s) LLENADO por vela de %s",
                //            isBull ? "Alcista" : "Bajista", EnumToString(checkTF), fvgS, fvgE, TimeToString(fvgFormTimeCandle1), TimeToString(outFillTime));
                return true; // Encontrado un FVG llenado recientemente (el más reciente, ya que iteramos FVG desde más antiguo)
            }
             // Si la vela 'k' no llenó el FVG, y su rango está completamente fuera del FVG en la dirección opuesta al llenado,
             // entonces el FVG no se llenó y el precio se movió. No seguir buscando para este FVG.
            if(isBull && ratesHTF[k].high > fvgE && ratesHTF[k].low > fvgE) break; // Precio se movió arriba sin llenar FVG alcista
            if(!isBull && ratesHTF[k].low < fvgS && ratesHTF[k].high < fvgS) break; // Precio se movió abajo sin llenar FVG bajista
        }
    }
    return false;
}

// Implementación de FindOBOriginatingSweep (ya proporcionada y modificada en la Sección 1.1)
OrderBlock FindOBOriginatingSweep(datetime sweepTimeActual, double sweptLevelPrice, bool wasBuysideSwept, ENUM_TIMEFRAMES obTF)
{
    // ... Copiar la función FindOBOriginatingSweep completa aquí ...
    OrderBlock foundOB = {0}; foundOB.isValid = false;
    bool lookForBullishOB_Origin = !wasBuysideSwept; // Si se barrió un HIGH, OB originador es BAJISTA

    MqlRates ratesOB[];
    int barsToScan = inpNarrative_LookbackBarsHTF + 60; // Mirar más atrás en obTF
    if(CopyRates(Symbol(), obTF, 0, barsToScan, ratesOB) < 20) return foundOB;
    ArraySetAsSeries(ratesOB, true);

    double atrOBTFLocal = ComputeATR(obTF, ATRPeriod_M15);
    if(atrOBTFLocal <=0) atrOBTFLocal = SymbolInfoDouble(Symbol(), SYMBOL_POINT) * 10;

    for(int i = 1; i < barsToScan -1; i++) // i = vela OB, i-1 = vela desplazamiento
    {
        if(ratesOB[i].time >= sweepTimeActual) continue; // OB debe ser ANTES del barrido

        bool isCandOB = false;
        if(lookForBullishOB_Origin && ratesOB[i].close < ratesOB[i].open) isCandOB = true;
        else if(!lookForBullishOB_Origin && ratesOB[i].close > ratesOB[i].open) isCandOB = true;
        if(!isCandOB) continue;

        bool displacementOK = false;
        double displacementMin = atrOBTFLocal * inpOB_StrongDisplacementATRRatio * 0.7; // Desplazamiento mínimo
        if(lookForBullishOB_Origin && (ratesOB[i-1].close > ratesOB[i].high + displacementMin)) displacementOK = true;
        else if(!lookForBullishOB_Origin && (ratesOB[i-1].close < ratesOB[i].low - displacementMin)) displacementOK = true;
        if(!displacementOK) continue;

        OrderBlock currentOB;
        currentOB.isBullish = lookForBullishOB_Origin;
        currentOB.openPrice = ratesOB[i].open; currentOB.closePrice = ratesOB[i].close;
        currentOB.highPrice = ratesOB[i].high; currentOB.lowPrice = ratesOB[i].low;
        currentOB.time = ratesOB[i].time;
        currentOB.isValid = true;
        
        // El OB originador idealmente "toca" o está muy cerca del nivel barrido
        bool relevantToSweepPrice = false;
        double proximityTol = atrOBTFLocal * 0.5;
        if(lookForBullishOB_Origin && currentOB.lowPrice <= sweptLevelPrice + proximityTol && currentOB.highPrice >= sweptLevelPrice - atrOBTFLocal*2.0) relevantToSweepPrice = true; // OB alcista está en o debajo del low barrido
        if(!lookForBullishOB_Origin && currentOB.highPrice >= sweptLevelPrice - proximityTol && currentOB.lowPrice <= sweptLevelPrice + atrOBTFLocal*2.0) relevantToSweepPrice = true; // OB bajista está en o encima del high barrido
        if(!relevantToSweepPrice) continue;


        currentOB.quality = AssessOBQuality(currentOB, obTF);
        currentOB.isSwept = IsOBSwept(currentOB, obTF); // Chequear si este OB ya fue mitigado DESPUÉS de su formación

        if(!currentOB.isSwept && currentOB.quality >= inpMinOBQualityForEntry - 0.5) // Umbral un poco más bajo para narrativa
        {
            if(!foundOB.isValid || currentOB.quality > foundOB.quality || (currentOB.quality == foundOB.quality && currentOB.time > foundOB.time) )
            {
                foundOB = currentOB;
            }
        }
    }
    // if(foundOB.isValid) PrintFormat("FindOBOriginatingSweep: Encontrado OB %s en %s. Calidad: %.1f", foundOB.isBullish?"Bull":"Bear", EnumToString(obTF),foundOB.quality);
    return foundOB;
}

// Implementación de FindOBAlignedWithHTFFVG (ya proporcionada y modificada en la Sección 1.1)
OrderBlock FindOBAlignedWithHTFFVG(datetime fvgFillTimeHTF, bool fvgWasBullishHTF, ENUM_TIMEFRAMES obLTF)
{
    // ... Copiar la función FindOBAlignedWithHTFFVG completa aquí ...
    OrderBlock foundOB = {0}; foundOB.isValid = false;
    bool lookForBullishOB_LTF_Align = fvgWasBullishHTF; // Si FVG HTF fue Alcista, buscar OB Alcista en LTF

    MqlRates ratesLTF[];
    int barsToScanLTF = 60;
    // El OB LTF debe formarse DESPUÉS o muy cerca del fvgFillTimeHTF
    int fillBarIndexLTF = iBarShift(Symbol(), obLTF, fvgFillTimeHTF, true); // exact=true
    if(fillBarIndexLTF <0) fillBarIndexLTF = 0; // Si no se encuentra, empezar desde la actual

    // Empezar a escanear desde un poco ANTES del fillBarIndexLTF hasta más atrás
    int startShift = MathMin(fillBarIndexLTF + 5, iBars(Symbol(),obLTF)-2); // Empezar a escanear velas que podrían ser el OB
                                                                        // Shift 0 es la actual, shift 1 es la cerrada anterior...
    if(startShift < 1) startShift = 1; // Asegurar al menos la vela cerrada anterior

    if(CopyRates(Symbol(), obLTF, 0, startShift + barsToScanLTF, ratesLTF) < barsToScanLTF) return foundOB;
    ArraySetAsSeries(ratesLTF, true); // ratesLTF[0] es la vela actual

    double atrLTFLocal = ComputeATR(obLTF, ATRPeriod_M15);
     if(atrLTFLocal <=0) atrLTFLocal = SymbolInfoDouble(Symbol(),SYMBOL_POINT) * 10;

    // Iterar desde (startShift) hacia atrás (índices mayores en 'ratesLTF')
    for(int i = startShift; i < startShift + barsToScanLTF -1 ; i++)
    {
        if(i >= ArraySize(ratesLTF)-1) break; // Asegurar que i+1 (vela de OB) e i (vela de desplazamiento) son válidos
        if(ratesLTF[i+1].time < fvgFillTimeHTF - (PeriodSeconds(obLTF)*5)) continue; // OB no demasiado antes del fill
        // ratesLTF[i+1] es la vela candidata a OB, ratesLTF[i] es la de desplazamiento

        bool isCandOB_LTF = false;
        if(lookForBullishOB_LTF_Align && ratesLTF[i+1].close < ratesLTF[i+1].open) isCandOB_LTF = true;
        else if(!lookForBullishOB_LTF_Align && ratesLTF[i+1].close > ratesLTF[i+1].open) isCandOB_LTF = true;
        if(!isCandOB_LTF) continue;

        bool displacementOK_LTF = false;
        double displacementMinLTF = atrLTFLocal * inpOB_StrongDisplacementATRRatio * 0.6;
        if(lookForBullishOB_LTF_Align && (ratesLTF[i].close > ratesLTF[i+1].high + displacementMinLTF)) displacementOK_LTF = true;
        else if(!lookForBullishOB_LTF_Align && (ratesLTF[i].close < ratesLTF[i+1].low - displacementMinLTF)) displacementOK_LTF = true;
        if(!displacementOK_LTF) continue;

        OrderBlock currentOB_LTF;
        currentOB_LTF.isBullish = lookForBullishOB_LTF_Align;
        currentOB_LTF.openPrice = ratesLTF[i+1].open; currentOB_LTF.closePrice = ratesLTF[i+1].close;
        currentOB_LTF.highPrice = ratesLTF[i+1].high; currentOB_LTF.lowPrice = ratesLTF[i+1].low;
        currentOB_LTF.time = ratesLTF[i+1].time;
        currentOB_LTF.isValid = true;

        currentOB_LTF.quality = AssessOBQuality(currentOB_LTF, obLTF);
        currentOB_LTF.isSwept = IsOBSwept(currentOB_LTF, obLTF);

        if(!currentOB_LTF.isSwept && currentOB_LTF.quality >= inpMinOBQualityForEntry - 0.8)
        {
            if(!foundOB.isValid || currentOB_LTF.quality > foundOB.quality || (currentOB_LTF.quality == foundOB.quality && currentOB_LTF.time > foundOB.time) )
            {
                foundOB = currentOB_LTF;
            }
        }
    }
    // if(foundOB.isValid) PrintFormat("FindOBAlignedWithHTFFVG: Encontrado OB LTF %s en %s. Calidad: %.1f", foundOB.isBullish?"Bull":"Bear", EnumToString(obLTF),foundOB.quality);
    return foundOB;
}

//+------------------------------------------------------------------+
//| Funciones de Lógica de Entrada (Silver Bullet, Confirmación M2022)|
//+------------------------------------------------------------------+
bool IsNYSilverBulletWindowActive(datetime currentTime)
{
    // Implementación de IsNYSilverBulletWindowActive (ya proporcionada en Sección 5.2)
    // ... Copiar la función IsNYSilverBulletWindowActive completa aquí ...
    if(!inpEnableNYSilverBullet) return false;
    MqlDateTime dt; TimeToStruct(currentTime, dt);
    int currentTotalMinutes = dt.hour * 60 + dt.min;
    int startTotalMinutes = inpNYSB_StartHour * 60 + inpNYSB_StartMinute;
    int endTotalMinutes = inpNYSB_EndHour * 60 + inpNYSB_EndMinute;

    if (startTotalMinutes < endTotalMinutes)
        return (currentTotalMinutes >= startTotalMinutes && currentTotalMinutes < endTotalMinutes);
    else if (startTotalMinutes > endTotalMinutes)
        return (currentTotalMinutes >= startTotalMinutes || currentTotalMinutes < endTotalMinutes);
    return false; // Ventana de 0 minutos
}

bool FindSweptSessionLiquidity(int lookbackM5ForHuntConfirm, double minHuntStrengthRequired,
                               datetime &outActualSweepTime, double &outSweptLiquidityLevel, bool &outWasBuysideSwept, string &outSweptSessionTypeName)
{
    // Implementación de FindSweptSessionLiquidity (ya proporcionada en Sección 5.2)
    // ... Copiar la función FindSweptSessionLiquidity completa aquí ...
    // Esta función ahora usa DetectStopHunt mejorado
    outActualSweepTime=0; outSweptLiquidityLevel=0; outWasBuysideSwept=false; outSweptSessionTypeName="";
    datetime huntOccTime =0; double penPrice =0; int huntStr =0;

    // ArraySort(liquidityZones, WHOLE_ARRAY, offsetof(LiquidityZone, time), MODE_DESCEND); // Más recientes primero

    for(int i=0; i<ArraySize(liquidityZones); i++) {
        if(ArraySize(liquidityZones)-i > 50 && i > 30) break; // Optimización

        LiquidityZone lz = liquidityZones[i];
        bool isSessLiq = (StringFind(lz.type, "Asia H")>=0 || StringFind(lz.type, "Asia L")>=0 ||
                          StringFind(lz.type, "London H")>=0 || StringFind(lz.type, "London L")>=0);
        if(!isSessLiq || lz.strength < inpLiq_StrengthExternalSession - 1.5) continue;

        if(DetectStopHunt(lz.price, lz.isBuySide, huntOccTime, penPrice, huntStr, PERIOD_M5)) { // Hunt en M5
            if(huntStr >= minHuntStrengthRequired) {
                // Asegurar que el barrido es "reciente" dentro de la ventana SB o poco antes
                long timeSinceHuntSeconds = TimeCurrent() - huntOccTime;
                if(timeSinceHuntSeconds <= (long)lookbackM5ForHuntConfirm * PeriodSeconds(PERIOD_M5) * 5 ) { // *5 para dar un margen
                    outActualSweepTime = huntOccTime;
                    outSweptLiquidityLevel = lz.price;
                    outWasBuysideSwept = lz.isBuySide;
                    outSweptSessionTypeName = lz.type;
                    return true;
                }
            }
        }
    }
    return false;
}

void CheckSilverBulletSetup()
{
    // Implementación de CheckSilverBulletSetup (ya proporcionada y modificada en Sección 5.2)
    // ... Copiar la función CheckSilverBulletSetup completa aquí ...
    if(!g_isInNYSilverBulletWindow) return;
    if(PositionsTotal() > 0 || g_tradesToday >= MaxTradesPerDay) return;
    if(inpNYSB_TradeOncePerSession && g_NYSilverBulletTradesToday > 0) {
        MqlDateTime dtLast, dtCrnt; TimeToStruct(g_lastNYSilverBulletTradeTime, dtLast); TimeToStruct(TimeCurrent(), dtCrnt);
        if(dtLast.day_of_year == dtCrnt.day_of_year && dtLast.year == dtCrnt.year) return;
        else g_NYSilverBulletTradesToday = 0;
    }

    datetime sweepT=0; double sweptL=0; bool wasBsideS=false; string sweptSessName="";
    if(!FindSweptSessionLiquidity(inpNYSB_LiqLookbackBarsM5, inpNYSB_HuntStrengthMin, sweepT, sweptL, wasBsideS, sweptSessName)) return;

    bool expectTradeBull = !wasBsideS;
    FairValueGap sbFVGFound = FindLastFVG(inpNYSB_FVG_TF, 25, 0, expectTradeBull, sweepT, inpNYSB_FVG_MinSizePips);
    if(sbFVGFound.startPrice == 0 || sbFVGFound.isFilled) return;

    double entrySB=0;
    if(expectTradeBull) { // Bullish FVG
        if(inpNYSB_FVGEntryMode == FVG_ENTRY_START) entrySB = sbFVGFound.startPrice;
        else if(inpNYSB_FVGEntryMode == FVG_ENTRY_MID) entrySB = (sbFVGFound.startPrice + sbFVGFound.endPrice) / 2.0;
        else entrySB = sbFVGFound.endPrice;
    } else { // Bearish FVG
        if(inpNYSB_FVGEntryMode == FVG_ENTRY_START) entrySB = sbFVGFound.startPrice;
        else if(inpNYSB_FVGEntryMode == FVG_ENTRY_MID) entrySB = (sbFVGFound.startPrice + sbFVGFound.endPrice) / 2.0;
        else entrySB = sbFVGFound.endPrice;
    }
    entrySB = NormalizeDouble(entrySB, _Digits);

    double point = SymbolInfoDouble(Symbol(), SYMBOL_POINT);
    double slPipsSB = inpNYSB_SL_Pips > 0 ? inpNYSB_SL_Pips : 7.0;
    double slPointsSB = slPipsSB * point * ((Digits()%2==1 && point <0.001)?10:1); if(slPointsSB<=0) slPointsSB = slPipsSB*0.0001;
    double stopLossSB_val = 0;
    // SL detrás del extremo del FVG o del nivel barrido
    if(expectTradeBull) stopLossSB_val = MathMin(sbFVGFound.startPrice - slPointsSB, sweptL - slPointsSB);
    else stopLossSB_val = MathMax(sbFVGFound.startPrice + slPointsSB, sweptL + slPointsSB);
    stopLossSB_val = NormalizeDouble(stopLossSB_val, _Digits);

    if(expectTradeBull && entrySB <= stopLossSB_val) return;
    if(!expectTradeBull && entrySB >= stopLossSB_val) return;

    double riskSB = MathAbs(entrySB - stopLossSB_val); if(riskSB < point*2.0) return;
    double takeProfitSB_val = 0;
    if(expectTradeBull) takeProfitSB_val = entrySB + (riskSB * inpNYSB_TP_RR);
    else takeProfitSB_val = entrySB - (riskSB * inpNYSB_TP_RR);
    takeProfitSB_val = NormalizeDouble(takeProfitSB_val, _Digits);

    double lotSB = CalculateLotSize(riskSB);
    string commSB = InpEAName + " NYSB " + (expectTradeBull ? "B" : "S") + " " + StringSubstr(sweptSessName,0,8);

    // PrintFormat("CheckSilverBulletSetup: Attempting SB Trade. Entry:%.5f SL:%.5f TP:%.5f Lot:%.2f Comm:%s", entrySB,stopLossSB_val,takeProfitSB_val,lotSB,commSB);
    if(OpenTrade(expectTradeBull, lotSB, entrySB, stopLossSB_val, takeProfitSB_val, commSB)) {
        g_lastNYSilverBulletTradeTime = TimeCurrent();
        g_NYSilverBulletTradesToday++;
    }
    return; // Solo un intento de SB por tick
}

void CheckEntryConfirmationM2022()
{
    // Implementación de CheckEntryConfirmationM2022 (ya proporcionada y modificada en Sección 2.2)
    // ... Copiar la función CheckEntryConfirmationM2022 completa aquí ...
    if(!g_waitingForEntryConfirmation || !inpEnableEntryConfirmationM2022) { g_waitingForEntryConfirmation = false; return; }
    datetime now = TimeCurrent();
    if((now - g_poiTouchTime_M2022) > (inpM2022_TimeoutBarsM5 * PeriodSeconds(inpOB_DetectionTF))) { // Timeout usa TF del POI
        // PrintFormat("M2022 Confirm: Timeout for POI @ %s", TimeToString(g_confirmedPOI_M2022.time));
        g_waitingForEntryConfirmation = false; return;
    }

    bool structureShiftOK = false; datetime shiftTimeLTF = 0; double shiftLowLTF=0, shiftHighLTF=0;
    MqlRates ratesConfirmTF[];
    int barsConfirm = MathMax(inpM2022_LookbackLTF, 15) + 5;
    if(CopyRates(Symbol(), inpM2022_ConfirmationTF, 0, barsConfirm, ratesConfirmTF) < barsConfirm-2) return;
    ArraySetAsSeries(ratesConfirmTF, true);

    for(int i=0; i < inpM2022_LookbackLTF; i++) { // i=0 es la última cerrada del inpM2022_ConfirmationTF
        if(ratesConfirmTF[i].time <= g_poiTouchTime_M2022) break; // Shift debe ser después del toque del POI
        if(DetectChoCH(inpM2022_ConfirmationTF, i+1, g_entryDirection_M2022, inpM2022_LookbackLTF) ||
           DetectBOS(inpM2022_ConfirmationTF, i+1, g_entryDirection_M2022, inpM2022_LookbackLTF)) {
            structureShiftOK = true; shiftTimeLTF = ratesConfirmTF[i].time;
            shiftLowLTF = ratesConfirmTF[i].low; shiftHighLTF = ratesConfirmTF[i].high;
            break;
        }
    }
    if(!structureShiftOK) return;

    FairValueGap confirmFVGFound = FindLastFVG(inpM2022_ConfirmationTF, inpM2022_LookbackLTF, 0, g_entryDirection_M2022, shiftTimeLTF, inpM2022_ConfirmFVGMinPips);
    if(confirmFVGFound.startPrice == 0 || confirmFVGFound.isFilled) return;

    double entryFVG_M2022=0;
    if(g_entryDirection_M2022) { // Bullish FVG
        if(inpM2022_FVGEntryMode == FVG_ENTRY_START) entryFVG_M2022 = confirmFVGFound.startPrice;
        else if(inpM2022_FVGEntryMode == FVG_ENTRY_MID) entryFVG_M2022 = (confirmFVGFound.startPrice + confirmFVGFound.endPrice) / 2.0;
        else entryFVG_M2022 = confirmFVGFound.endPrice;
    } else { // Bearish FVG
        if(inpM2022_FVGEntryMode == FVG_ENTRY_START) entryFVG_M2022 = confirmFVGFound.startPrice;
        else if(inpM2022_FVGEntryMode == FVG_ENTRY_MID) entryFVG_M2022 = (confirmFVGFound.startPrice + confirmFVGFound.endPrice) / 2.0;
        else entryFVG_M2022 = confirmFVGFound.endPrice;
    }
    entryFVG_M2022 = NormalizeDouble(entryFVG_M2022, _Digits);

    double stopLossM2022_val = 0;
    double point = SymbolInfoDouble(Symbol(), SYMBOL_POINT);
    double slBufferPts = inpM2022_ConfirmSLBufferPips * point * ((Digits()%2==1 && point <0.001)?10:1); if(slBufferPts<=0) slBufferPts = inpM2022_ConfirmSLBufferPips*0.0001;

    if(inpM2022_UseOriginalPOISL && g_confirmedPOI_M2022.isValid) {
        if(g_entryDirection_M2022) stopLossM2022_val = g_confirmedPOI_M2022.lowPrice - slBufferPts;
        else stopLossM2022_val = g_confirmedPOI_M2022.highPrice + slBufferPts;
    } else { // SL detrás del swing LTF (vela del ChoCH/BOS o extremo del FVG)
        if(g_entryDirection_M2022) stopLossM2022_val = MathMin(shiftLowLTF, confirmFVGFound.startPrice - point) - slBufferPts; // Bajo el low del swing LTF o inicio del FVG alcista
        else stopLossM2022_val = MathMax(shiftHighLTF, confirmFVGFound.startPrice + point) + slBufferPts; // Alto el high del swing LTF o inicio del FVG bajista
    }
    stopLossM2022_val = NormalizeDouble(stopLossM2022_val, _Digits);

    if(g_entryDirection_M2022 && entryFVG_M2022 <= stopLossM2022_val) { g_waitingForEntryConfirmation = false; return; }
    if(!g_entryDirection_M2022 && entryFVG_M2022 >= stopLossM2022_val) { g_waitingForEntryConfirmation = false; return; }
    
    double riskM2022 = MathAbs(entryFVG_M2022 - stopLossM2022_val); if(riskM2022 < point*2.0) {g_waitingForEntryConfirmation = false; return;}
    // TP para M2022 puede ser por R:R fijo o liquidez HTF
    double tpM2022 = 0;
    LiquidityZone liqTargetM2022 = FindNextRelevantLiquidityTarget(g_entryDirection_M2022, entryFVG_M2022, stopLossM2022_val);
    if(UseKeyLevelsForSLTP && liqTargetM2022.price != 0) {
        double tpMarginPts = KeyLevelTP_MarginPips * point * ((Digits()%2==1 && point <0.001)?10:1); if(tpMarginPts<=0) tpMarginPts = KeyLevelTP_MarginPips*0.0001;
        if(g_entryDirection_M2022) tpM2022 = liqTargetM2022.price - tpMarginPts;
        else tpM2022 = liqTargetM2022.price + tpMarginPts;
        // Validar R:R mínimo para TP de liquidez
        if(MathAbs(tpM2022 - entryFVG_M2022) / riskM2022 < 1.0 ) tpM2022 = 0; // Mínimo 1R
    }
    if(tpM2022 == 0) { // Fallback a R:R fijo
        if(g_entryDirection_M2022) tpM2022 = entryFVG_M2022 + (riskM2022 * RiskRewardRatio);
        else tpM2022 = entryFVG_M2022 - (riskM2022 * RiskRewardRatio);
    }
    tpM2022 = NormalizeDouble(tpM2022, _Digits);


    double lotM2022 = CalculateLotSize(riskM2022);
    string commM2022 = InpEAName + " M2022 " + (g_entryDirection_M2022 ? "B":"S") + " " + EnumToString(inpM2022_ConfirmationTF);
    // PrintFormat("M2022 Confirm: Attempting Trade. Entry:%.5f SL:%.5f TP:%.5f Lot:%.2f Comm:%s", entryFVG_M2022,stopLossM2022_val,tpM2022,lotM2022,commM2022);

    if(OpenTrade(g_entryDirection_M2022, lotM2022, entryFVG_M2022, stopLossM2022_val, tpM2022, commM2022)) {
        // Trade abierto
    }
    g_waitingForEntryConfirmation = false;
}

//+------------------------------------------------------------------+
//| CheckTradeEntries - Lógica Principal para Entradas en POIs       |
//+------------------------------------------------------------------+
void CheckTradeEntries()
{
    if(PositionsTotal() > 0 || g_tradesToday >= MaxTradesPerDay) return;
    if(g_waitingForEntryConfirmation) return; // Si ya estamos esperando confirmación M2022, no buscar nueva entrada POI

    // --- 1. Verificación de Bias y Estructura de Mercado ---
    bool overallBiasIsBullish = g_H4BiasIsBullish; // Usar H4 como principal
    if(UseDailyBias && g_D1BiasIsBullish != g_H4BiasIsBullish) {
        // Print("CheckTradeEntries: Bias D1 y H4 no alineados. No hay trade.");
        return; // D1 y H4 deben estar alineados si UseDailyBias es true
    }

    // Estructura M15 debe estar alineada o en rango. g_m15Structure se actualiza en OnTick.
    if(!((overallBiasIsBullish && (g_m15Structure == MSS_BULLISH || g_m15Structure == MSS_RANGE || g_m15Structure == MSS_UNKNOWN)) ||
         (!overallBiasIsBullish && (g_m15Structure == MSS_BEARISH || g_m15Structure == MSS_RANGE || g_m15Structure == MSS_UNKNOWN)) ))
    {
        // PrintFormat("CheckTradeEntries: Estructura M15 (%s) no alineada con Bias (%s). No hay trade.", EnumToString(g_m15Structure), overallBiasIsBullish?"Bull":"Bear");
        return;
    }

    // --- 2. Selección del Punto de Interés (POI) ---
    OrderBlock       targetPOI = {0}; // El POI final seleccionado
    targetPOI.isValid = false;
    string           poiSourceType = ""; // "OB-NarrativeSweep", "OB-NarrativeFVG", "OB", "BB"

    // 2.1 Prioridad a POIs de Narrativa
    if(g_priceNarrative == NARRATIVE_REPRICING_AFTER_SWEEP && g_lastSignificantSweepTime_Narrative > 0)
    {
        bool narrativeTradeDirectionBullish = !g_lastSignificantSweepWasBuySide_Narrative;
        if(narrativeTradeDirectionBullish == overallBiasIsBullish) // Alineado con bias general
        {
            OrderBlock narrativeOB = FindOBOriginatingSweep(g_lastSignificantSweepTime_Narrative, g_lastSignificantSweepLevel_Narrative,
                                                          g_lastSignificantSweepWasBuySide_Narrative, inpOB_DetectionTF);
            if(narrativeOB.isValid && narrativeOB.quality >= inpMinOBQualityForEntry - 1.0) // Umbral ligeramente menor para narrativa
            {
                targetPOI = narrativeOB;
                poiSourceType = "OB-NarrSweep";
                // PrintFormat("CheckTradeEntries: POI por Narrativa (Barrido) seleccionado. Tipo: %s, Tiempo: %s, Calidad: %.1f",
                //            targetPOI.isBullish?"Bull":"Bear", TimeToString(targetPOI.time), targetPOI.quality);
            }
        }
    }
    else if(g_priceNarrative == NARRATIVE_REPRICING_AFTER_HTF_FVG_FILL && g_lastHTFFVGFillTime_Narrative > 0 && !targetPOI.isValid)
    {
        bool narrativeTradeDirectionBullish = g_lastHTFFVGFillWasBullish_Narrative;
        if(narrativeTradeDirectionBullish == overallBiasIsBullish)
        {
            OrderBlock narrativeOB = FindOBAlignedWithHTFFVG(g_lastHTFFVGFillTime_Narrative, g_lastHTFFVGFillWasBullish_Narrative, inpOB_DetectionTF); // Usar TF de OB
            if(narrativeOB.isValid && narrativeOB.quality >= inpMinOBQualityForEntry - 1.0)
            {
                targetPOI = narrativeOB;
                poiSourceType = "OB-NarrFVG";
                // PrintFormat("CheckTradeEntries: POI por Narrativa (FVG Fill) seleccionado. Tipo: %s, Tiempo: %s, Calidad: %.1f",
                //            targetPOI.isBullish?"Bull":"Bear", TimeToString(targetPOI.time), targetPOI.quality);
            }
        }
    }

    // 2.2 Si no hay POI de narrativa, buscar OBs/BBs genéricos
    if(!targetPOI.isValid)
    {
        // Buscar en OrderBlocks (ya están ordenados por calidad en DetectOrderBlocks)
        for(int i = 0; i < ArraySize(orderBlocks); i++)
        {
            if(orderBlocks[i].isBullish == overallBiasIsBullish && // Alineado con bias
               !orderBlocks[i].isSwept &&                        // No mitigado
               orderBlocks[i].quality >= inpMinOBQualityForEntry) // Calidad suficiente
            {
                targetPOI = orderBlocks[i];
                poiSourceType = "OB";
                // PrintFormat("CheckTradeEntries: POI Genérico (OB) seleccionado. Tipo: %s, Tiempo: %s, Calidad: %.1f",
                //             targetPOI.isBullish?"Bull":"Bear", TimeToString(targetPOI.time), targetPOI.quality);
                break;
            }
        }

        if(!targetPOI.isValid) // Si no se encontró OB, buscar Breakers
        {
            // Ordenar Breakers por calidad si tienen qualityScore, o tomar el más reciente
            // (Asumir que DetectBreakerBlocks ya los filtró por validez y no mitigación)
            for(int i = 0; i < ArraySize(breakerBlocks); i++)
            {
                if(breakerBlocks[i].isBullish == overallBiasIsBullish &&
                   breakerBlocks[i].qualityScore >= inpMinBBQualityForEntry)
                {
                    // Convertir Breaker a una estructura temporal compatible con POI (OrderBlock) para entry/SL
                    targetPOI.isBullish = breakerBlocks[i].isBullish;
                    targetPOI.highPrice = breakerBlocks[i].price + ComputeATR(inpOB_DetectionTF, ATRPeriod_M15) * 0.2; // Estimar rango
                    targetPOI.lowPrice  = breakerBlocks[i].price - ComputeATR(inpOB_DetectionTF, ATRPeriod_M15) * 0.2;
                    targetPOI.openPrice = breakerBlocks[i].price; // El nivel del breaker es el punto clave
                    targetPOI.closePrice= breakerBlocks[i].price;
                    targetPOI.time      = breakerBlocks[i].confirmationTime; // Usar tiempo de confirmación del BB
                    targetPOI.isValid   = true;
                    targetPOI.quality   = breakerBlocks[i].qualityScore;
                    targetPOI.isSwept   = false; // Asumido por la detección de BB
                    poiSourceType = "BB";
                    // PrintFormat("CheckTradeEntries: POI Genérico (BB) seleccionado. Tipo: %s, Nivel: %.5f, Calidad: %.1f",
                    //             targetPOI.isBullish?"Bull":"Bear", targetPOI.openPrice, targetPOI.quality);
                    break;
                }
            }
        }
    }

    if(!targetPOI.isValid) {
        // Print("CheckTradeEntries: No se encontró ningún POI válido después de todos los chequeos.");
        return;
    }

    // --- 3. Aplicar Bonus de Desviación Estándar a la calidad del POI ---
    double poiNominalEntryPrice = 0; // Precio nominal de entrada para el POI (antes de ajuste a mercado)
    // Calcular precio de entrada nominal basado en targetPOI y inpOB_EntryMode
    // Este precio se usará para chequear alineación con DE
    if(targetPOI.isBullish) { // POI Alcista
        if(inpOB_EntryMode == OB_ENTRY_OPEN) poiNominalEntryPrice = targetPOI.openPrice; // Apertura de la vela bajista del OB
        else if(inpOB_EntryMode == OB_ENTRY_BODY_50) poiNominalEntryPrice = (targetPOI.openPrice + targetPOI.closePrice) / 2.0;
        else poiNominalEntryPrice = targetPOI.highPrice; // O el High para ser más conservador al comprar
    } else { // POI Bajista
        if(inpOB_EntryMode == OB_ENTRY_OPEN) poiNominalEntryPrice = targetPOI.openPrice; // Apertura de la vela alcista del OB
        else if(inpOB_EntryMode == OB_ENTRY_BODY_50) poiNominalEntryPrice = (targetPOI.openPrice + targetPOI.closePrice) / 2.0;
        else poiNominalEntryPrice = targetPOI.lowPrice; // O el Low para ser más conservador al vender
    }


    if(inpEnableStdDevProjections && g_stdDevProjections.calculationTime > 0 && g_stdDevProjections.stdDev > 0 && poiNominalEntryPrice > 0)
    {
        double point = SymbolInfoDouble(Symbol(), SYMBOL_POINT);
        double toleranceStdDevPoints = inpStdDev_ProjectionTolerancePips * point * ((Digits() % 2 == 1 && point < 0.001) ? 10:1);
        if(toleranceStdDevPoints <=0 && point > 0) toleranceStdDevPoints = inpStdDev_ProjectionTolerancePips * point;
        else if(toleranceStdDevPoints <=0) toleranceStdDevPoints = inpStdDev_ProjectionTolerancePips * 0.0001;


        double projections[] = {
            g_stdDevProjections.projPlus1, g_stdDevProjections.projPlus2, g_stdDevProjections.projPlus2_5, g_stdDevProjections.projPlus4,
            g_stdDevProjections.projMinus1, g_stdDevProjections.projMinus2, g_stdDevProjections.projMinus2_5, g_stdDevProjections.projMinus4
        };
        for(int k = 0; k < ArraySize(projections); k++) {
            if(projections[k] == 0) continue;
            if(MathAbs(poiNominalEntryPrice - projections[k]) <= toleranceStdDevPoints) {
                targetPOI.quality += inpStdDev_ProjectionQualityBonus;
                // PrintFormat("CheckTradeEntries: POI (%s @ %.5f) alineado con Proyección DE. Nueva Calidad: %.1f", poiSourceType, poiNominalEntryPrice, targetPOI.quality);
                break;
            }
        }
        targetPOI.quality = MathMax(0.0, MathMin(10.0, targetPOI.quality));
    }

    // --- 4. Aplicar Bonus de Golden Killzone Hour a la calidad del POI ---
    if(inpEnableKillzonePonderation && g_isInGoldenKillzoneHour)
    {
        targetPOI.quality += inpKz_GoldenHourQualityBonus;
        targetPOI.quality = MathMax(0.0, MathMin(10.0, targetPOI.quality));
        // PrintFormat("CheckTradeEntries: Bonus Golden KZ aplicado a POI (%s). Nueva Calidad: %.1f", poiSourceType, targetPOI.quality);
    }

    // --- 5. Verificar Calidad Final del POI ---
    if(poiSourceType == "BB" && targetPOI.quality < inpMinBBQualityForEntry) {
        // PrintFormat("CheckTradeEntries: Breaker Block no cumple calidad mínima (%.1f < %.1f)", targetPOI.quality, inpMinBBQualityForEntry);
        return;
    } else if (StringFind(poiSourceType, "OB") >=0 && targetPOI.quality < inpMinOBQualityForEntry) {
         // PrintFormat("CheckTradeEntries: Order Block no cumple calidad mínima (%.1f < %.1f)", targetPOI.quality, inpMinOBQualityForEntry);
        return;
    }


    // --- 6. Calcular Precio de Entrada Real y Stop Loss para el targetPOI ---
    double actualEntryPrice = 0; // Precio final de entrada (puede ser ajustado a mercado)
    double stopLossPrice = 0;
    double point = SymbolInfoDouble(Symbol(), SYMBOL_POINT);
    double atrForSL = ComputeATR(inpOB_DetectionTF, ATRPeriod_M15); // ATR del TF del POI
    if(atrForSL <=0) atrForSL = StopLossPips * point * ((Digits()%2==1 && point <0.001)?10:1); // Fallback
    if(atrForSL <=0) atrForSL = StopLossPips * 0.0001;


    double slBufferPoints = MathMax(StopLossPips * point * ((Digits()%2==1 && point <0.001)?10:1), atrForSL * ATRBufferFactor);
    if(slBufferPoints <=0) slBufferPoints = StopLossPips * 0.0001 * ATRBufferFactor;


    if(targetPOI.isBullish) { // POI Alcista
        // Entrada: Open o 50% del OB (vela bajista), o High para agresivo
        if(inpOB_EntryMode == OB_ENTRY_OPEN) actualEntryPrice = targetPOI.openPrice;
        else if(inpOB_EntryMode == OB_ENTRY_BODY_50) actualEntryPrice = (targetPOI.openPrice + targetPOI.closePrice) / 2.0;
        else actualEntryPrice = targetPOI.highPrice; // Entrar en el High de la vela bajista (esperando que lo rompa)
        stopLossPrice = targetPOI.lowPrice - slBufferPoints;
    } else { // POI Bajista
        if(inpOB_EntryMode == OB_ENTRY_OPEN) actualEntryPrice = targetPOI.openPrice;
        else if(inpOB_EntryMode == OB_ENTRY_BODY_50) actualEntryPrice = (targetPOI.openPrice + targetPOI.closePrice) / 2.0;
        else actualEntryPrice = targetPOI.lowPrice; // Entrar en el Low de la vela alcista
        stopLossPrice = targetPOI.highPrice + slBufferPoints;
    }
    
    if(actualEntryPrice == 0 || stopLossPrice == 0) {
        // Print("CheckTradeEntries: Error al calcular entry/SL para POI.");
        return;
    }

    // --- 7. Verificar si el Precio Actual está en la Zona de Entrada del POI ---
    double currentAsk = SymbolInfoDouble(Symbol(), SYMBOL_ASK);
    double currentBid = SymbolInfoDouble(Symbol(), SYMBOL_BID);
    double entryTolerancePointsValue = EntryTolerancePips * point * ((Digits() % 2 == 1 && point < 0.001) ? 10:1);
    if(entryTolerancePointsValue <=0 && point>0) entryTolerancePointsValue = EntryTolerancePips * point;
    else if(entryTolerancePointsValue <=0) entryTolerancePointsValue = EntryTolerancePips * 0.0001;


    bool priceIsInZoneNow = false;
    if(targetPOI.isBullish) {
       // Para compra, queremos que Ask esté cerca o por debajo de 'actualEntryPrice' (que es un nivel en el POI)
       // y por encima del SL.
       if(currentAsk <= actualEntryPrice + entryTolerancePointsValue && currentAsk > stopLossPrice) {
           priceIsInZoneNow = true;
           if(currentAsk > actualEntryPrice) actualEntryPrice = currentAsk; // Ajustar a mercado si ya pasó un poco
       }
    } else { // POI Bajista
       // Para venta, queremos que Bid esté cerca o por encima de 'actualEntryPrice'
       // y por debajo del SL.
       if(currentBid >= actualEntryPrice - entryTolerancePointsValue && currentBid < stopLossPrice) {
            priceIsInZoneNow = true;
            if(currentBid < actualEntryPrice) actualEntryPrice = currentBid; // Ajustar a mercado
       }
    }

    if(!priceIsInZoneNow) {
        // PrintFormat("CheckTradeEntries: Precio no en zona para POI %s. Entry:%.5f Ask:%.5f Bid:%.5f", poiSourceType, actualEntryPrice, currentAsk, currentBid);
        return;
    }

    // --- 8. Decidir si se usa Confirmación M2022 o Entrada Directa ---
    if(inpEnableEntryConfirmationM2022)
    {
        if(!g_waitingForEntryConfirmation) // Solo activar si no estamos ya esperando
        {
            g_confirmedPOI_M2022 = targetPOI;
            g_poiTouchTime_M2022 = iTime(Symbol(), inpOB_DetectionTF, 0); // Tiempo de la vela actual del TF del POI
            g_entryDirection_M2022 = targetPOI.isBullish;
            g_waitingForEntryConfirmation = true;
            // PrintFormat("CheckTradeEntries: POI %s (%s @ %.5f) tocado. Activando espera de confirmación M2022. Dirección: %s. TouchTime (aprox): %s",
            //             poiSourceType, targetPOI.isBullish?"Bull":"Bear", actualEntryPrice,
            //             g_entryDirection_M2022 ? "Bullish":"Bearish", TimeToString(g_poiTouchTime_M2022));
        }
        return; // Salir, la lógica de confirmación se maneja en OnTick -> CheckEntryConfirmationM2022
    }
    else // Entrada Directa (Confirmación M2022 desactivada)
    {
        double riskValue = MathAbs(actualEntryPrice - stopLossPrice);
        if(riskValue < point * 2.0) { // Riesgo demasiado pequeño
            // Print("CheckTradeEntries (Directa): Riesgo demasiado pequeño para el trade. Abortando.");
            return;
        }
        double lotSizeVal = CalculateLotSize(riskValue);
        
        // Calcular TP para entrada directa
        double takeProfitPrice = 0;
        LiquidityZone liqTarget = FindNextRelevantLiquidityTarget(targetPOI.isBullish, actualEntryPrice, stopLossPrice);
        if(UseKeyLevelsForSLTP && liqTarget.price != 0) {
            double tpMarginPtsVal = KeyLevelTP_MarginPips * point * ((Digits()%2==1 && point <0.001)?10:1); if(tpMarginPtsVal<=0) tpMarginPtsVal = KeyLevelTP_MarginPips*0.0001;
            if(targetPOI.isBullish) takeProfitPrice = liqTarget.price - tpMarginPtsVal;
            else takeProfitPrice = liqTarget.price + tpMarginPtsVal;
            if(MathAbs(takeProfitPrice - actualEntryPrice) / riskValue < 0.8 ) takeProfitPrice = 0; // Mínimo R:R de 0.8
        }
        if(takeProfitPrice == 0) {
            if(targetPOI.isBullish) takeProfitPrice = actualEntryPrice + (riskValue * RiskRewardRatio);
            else takeProfitPrice = actualEntryPrice - (riskValue * RiskRewardRatio);
        }
        
        actualEntryPrice = NormalizeDouble(actualEntryPrice, _Digits);
        stopLossPrice = NormalizeDouble(stopLossPrice, _Digits);
        takeProfitPrice = NormalizeDouble(takeProfitPrice, _Digits);

        string tradeComment = InpEAName + " " + poiSourceType + (targetPOI.isBullish ? " B" : " S");
        tradeComment += " Q" + DoubleToString(targetPOI.quality,1) + " N:" + ShortNarrative(g_priceNarrative);

        // PrintFormat("CheckTradeEntries (Directa): Intentando Trade. Comm: %s. Entry:%.5f SL:%.5f TP:%.5f Lot:%.2f",
        //             tradeComment, actualEntryPrice, stopLossPrice, takeProfitPrice, lotSizeVal);

        OpenTrade(targetPOI.isBullish, lotSizeVal, actualEntryPrice, stopLossPrice, takeProfitPrice, tradeComment);
    }
}

string ShortNarrative(PriceNarrativeContext narr) { // Helper para comentario
    switch(narr){
        case NARRATIVE_SEEKING_LIQUIDITY: return "SeekL";
        case NARRATIVE_REPRICING_AFTER_SWEEP: return "RepS";
        case NARRATIVE_REPRICING_AFTER_HTF_FVG_FILL: return "RepFVG";
        default: return "UnknN";
    }
}


//+------------------------------------------------------------------+
//| Funciones de Gestión de Órdenes y Riesgo                         |
//+------------------------------------------------------------------+

// --- Gestión de Volumen Inicial ---
int FindTicketIndex(ulong ticket) {
    for(int i = 0; i < ArraySize(g_positionTickets); i++) if(g_positionTickets[i] == ticket) return i;
    return -1;
}
void StoreInitialVolume(ulong ticket, double volume) {
    int index = FindTicketIndex(ticket);
    if(index == -1 && ArraySize(g_positionTickets) < 100) { // Limitar tamaño
        int size = ArraySize(g_positionTickets);
        ArrayResize(g_positionTickets, size + 1); ArrayResize(g_initialVolumes, size + 1);
        g_positionTickets[size] = ticket; g_initialVolumes[size] = volume;
    } else if (index != -1) g_initialVolumes[index] = volume;
}
double GetStoredInitialVolume(ulong ticket) {
    int index = FindTicketIndex(ticket);
    if(index != -1) return g_initialVolumes[index];
    // Si no se encuentra, podría ser un trade antiguo o no gestionado por esta instancia del EA.
    // Devolver el volumen actual de la posición como fallback si es necesario.
    if(PositionSelectByTicket(ticket)) return PositionGetDouble(POSITION_VOLUME);
    return 0.0;
}
void RemoveStoredVolume(ulong ticket) {
    int index = FindTicketIndex(ticket);
    if(index != -1) {
        int lastIdx = ArraySize(g_positionTickets) - 1;
        if (index != lastIdx) {
             g_positionTickets[index] = g_positionTickets[lastIdx];
             g_initialVolumes[index] = g_initialVolumes[lastIdx];
        }
        if(lastIdx >=0 ) { // Asegurar que no intentamos redimensionar a negativo
            ArrayResize(g_positionTickets, lastIdx); ArrayResize(g_initialVolumes, lastIdx);
        }
    }
}

// --- OpenTrade (Mejorado) ---
bool OpenTrade(bool isLong, double lot, double entryPrice, double stopLoss, double takeProfit, string comment)
{
    // Implementación de OpenTrade (ya proporcionada y modificada en la Sección 3.2)
    // ... Copiar la función OpenTrade completa aquí, asegurándose que usa 'trade.OrderSend' etc. y maneja errores.
    if(lot <= 0) { PrintFormat("OpenTrade Error: Lote inválido %.2f", lot); return false;}
    lot = NormalizeDouble(lot,2);
    if(lot < SymbolInfoDouble(Symbol(), SYMBOL_VOLUME_MIN)) lot = SymbolInfoDouble(Symbol(), SYMBOL_VOLUME_MIN);

    // Ajustar SL si está cerca de liquidez (opcional, ya que TP se basa en liquidez o R:R del SL original)
    // Por ahora, se omite este ajuste de SL aquí para simplificar, asumiendo que el SL ya es estructural.

    MqlTradeRequest request={1}; MqlTradeResult result={0};
    request.action = TRADE_ACTION_DEAL;
    request.symbol = Symbol();
    request.volume = lot;
    request.type = isLong ? ORDER_TYPE_BUY : ORDER_TYPE_SELL;
    request.price = SymbolInfoDouble(Symbol(), isLong ? SYMBOL_ASK : SYMBOL_BID); // Precio de mercado
    request.sl = NormalizeDouble(stopLoss, _Digits);
    if(takeProfit > 0) request.tp = NormalizeDouble(takeProfit, _Digits); else request.tp = 0;
    request.deviation = 30; // Deslizamiento mayor para asegurar ejecución
    request.magic = MagicNumberEA;
    request.comment = comment;
    request.type_filling = ORDER_FILLING_FOK; // Por defecto FOK

    bool orderSentOk = false;
    if(!trade.OrderSend(request, result)) {
        PrintFormat("OpenTrade: FOK Falló. Ret: %d (%s), Comm: %s. Err: %d. SL:%.5f TP:%.5f", result.retcode, trade.ResultComment(), result.comment, GetLastError(), request.sl, request.tp);
        if(result.retcode == TRADE_RETCODE_REQUOTE || result.retcode == TRADE_RETCODE_PRICE_OFF || result.retcode == TRADE_RETCODE_NO_MONEY || result.retcode == TRADE_RETCODE_TIMEOUT) {
            request.type_filling = ORDER_FILLING_IOC; // Probar IOC
            if(!trade.OrderSend(request, result)) {
                 PrintFormat("OpenTrade: IOC Falló. Ret: %d (%s), Comm: %s. Err: %d", result.retcode, trade.ResultComment(), result.comment, GetLastError());
                 return false;
            } else {
                 if(result.retcode == TRADE_RETCODE_DONE || result.retcode == TRADE_RETCODE_DONE_PARTIAL) orderSentOk = true;
                 else { PrintFormat("OpenTrade: IOC Enviado, pero no DONE. Ret: %d", result.retcode); return false;}
            }
        } else return false; // Error FOK no recuperable con IOC
    } else {
        if(result.retcode == TRADE_RETCODE_DONE) orderSentOk = true;
        else {PrintFormat("OpenTrade: FOK OK, pero retcode no DONE: %d", result.retcode); return false;}
    }

    if(orderSentOk){
        // PrintFormat("OpenTrade: Orden Enviada OK. Deal:%I64u, Order:%I64u. Comm:%s", result.deal, result.order, comment);
        Sleep(500); // Pausa para que la posición aparezca
        ulong positionTicketFound = 0;
        double actualVolumeOpened = 0;

        if(result.deal > 0) { // Si el deal ticket es válido
            // A veces el result.deal es el ticket de la posición, otras no directamente.
            // Es más fiable buscar la última posición con el magic y comentario.
        }
        
        // Buscar la posición por magic, símbolo y comentario reciente
        for(int k=PositionsTotal()-1; k>=0; k--){
            if(PositionGetTicket(k)){
                if(PositionGetInteger(POSITION_MAGIC) == MagicNumberEA &&
                   PositionGetString(POSITION_SYMBOL) == Symbol() &&
                   PositionGetString(POSITION_COMMENT) == comment && // Comentario exacto
                   (TimeCurrent() - (datetime)PositionGetInteger(POSITION_TIME) < 15) // Muy reciente
                  )
                {
                    positionTicketFound = PositionGetInteger(POSITION_TICKET);
                    actualVolumeOpened = PositionGetDouble(POSITION_VOLUME);
                    break;
                }
            }
        }
        
        if(positionTicketFound > 0 && actualVolumeOpened > 0){
            StoreInitialVolume(positionTicketFound, actualVolumeOpened);
            g_tradesToday++;
            g_lastTradeTimeThisSessionH4 = iTime(Symbol(), PERIOD_H4, 0); // O TF de la sesión actual
            // PrintFormat("OpenTrade: Posición %I64u confirmada. Volumen inicial: %.2f", positionTicketFound, actualVolumeOpened);
            return true;
        } else {
            // PrintFormat("OpenTrade: Orden enviada pero no se pudo confirmar la posición inmediatamente. Deal: %I64u. Comentario Buscado: %s", result.deal, comment);
            // Aún así, contar como trade si la orden fue aceptada.
            g_tradesToday++;
            g_lastTradeTimeThisSessionH4 = iTime(Symbol(), PERIOD_H4, 0);
            return true; // La orden fue aceptada, pero el seguimiento del volumen puede fallar.
        }
    }
    return false;
}

//+------------------------------------------------------------------+
//| Funciones de Gestión de Trades (Continuación)                    |
//+------------------------------------------------------------------+

// --- IsStopLossNearLiquidity (para OpenTrade y ManageRisk si es necesario) ---
bool IsStopLossNearLiquidity(double proposedSL, bool isTradeLong, double proximityPips, string &outLiqTypeHit)
{
    outLiqTypeHit = "";
    if(ArraySize(liquidityZones) == 0 || proximityPips <= 0) return false;
    double point = SymbolInfoDouble(Symbol(), SYMBOL_POINT);
    double proximityPoints = proximityPips * point * ((Digits() % 2 == 1 && point < 0.001) ? 10:1);
    if(proximityPoints <=0 && point >0) proximityPoints = proximityPips*point; else if(proximityPoints <=0) proximityPoints = proximityPips*0.0001;


    for(int i = 0; i < ArraySize(liquidityZones); i++)
    {
        // Considerar solo zonas de liquidez fuertes y del lado opuesto al SL
        // Si trade es LONG, SL está abajo (sell-side liquidity es relevante, isBuySide=false)
        // Si trade es SHORT, SL está arriba (buy-side liquidity es relevante, isBuySide=true)
        if(liquidityZones[i].strength >= inpMinLiqStrengthForTP - 1.0 && // Umbral de fuerza
           liquidityZones[i].isBuySide != isTradeLong) // Liquidez en el lado del SL
        {
            if(MathAbs(liquidityZones[i].price - proposedSL) <= proximityPoints)
            {
                outLiqTypeHit = liquidityZones[i].type + (liquidityZones[i].isBuySide?" H":" L");
                // PrintFormat("IsStopLossNearLiquidity: SL propuesto (%.5f) cerca de liquidez '%s' (%.5f)",
                //             proposedSL, outLiqTypeHit, liquidityZones[i].price);
                return true;
            }
        }
    }
    return false;
}

// --- FindNextRelevantLiquidityTarget (para TP dinámico) ---
LiquidityZone FindNextRelevantLiquidityTarget(bool isLong, double entryPrice, double initialStopLossValue) // SL value, not price
{
    // Implementación de FindNextRelevantLiquidityTarget (ya proporcionada en Sección 3.2)
    // ... Copiar la función FindNextRelevantLiquidityTarget completa aquí ...
    LiquidityZone targetZone = {0,false,0,0,"",LIQUIDITY_SCOPE_UNKNOWN,0,false};
    double bestTargetPriceFound = 0;
    double point = SymbolInfoDouble(Symbol(), SYMBOL_POINT);
    int digits = _Digits; // Usar global _Digits
    double pipsFactor = ((digits==3||digits==5) && point < 0.001) ? 10.0 : 1.0; // Ajuste para JPY y Oro.

    double minDistanceToTPPoints = inpMinDistToLiqTP_Pips * point * pipsFactor;
    if(minDistanceToTPPoints <=0 && point > 0) minDistanceToTPPoints = inpMinDistToLiqTP_Pips * point;
    else if(minDistanceToTPPoints <=0) minDistanceToTPPoints = inpMinDistToLiqTP_Pips * 0.0001 * pipsFactor;


    for(int i = 0; i < ArraySize(liquidityZones); i++)
    {
        LiquidityZone currentZoneCandidate = liquidityZones[i];
        if(currentZoneCandidate.strength < inpMinLiqStrengthForTP) continue;

        if(isLong) { // Buscamos liquidez de COMPRA (Highs) POR ENCIMA de la entrada
            if(!currentZoneCandidate.isBuySide || currentZoneCandidate.price <= entryPrice + minDistanceToTPPoints) continue;
            if(bestTargetPriceFound == 0 || currentZoneCandidate.price < bestTargetPriceFound) { // Más cercano
                if(initialStopLossValue > point && inpMaxDistToLiqTP_RR > 0) {
                    double rewardPotential = currentZoneCandidate.price - entryPrice;
                    if(rewardPotential / initialStopLossValue > inpMaxDistToLiqTP_RR) continue; // Demasiado lejos en RR
                }
                bestTargetPriceFound = currentZoneCandidate.price;
                targetZone = currentZoneCandidate;
            }
        } else { // Buscamos liquidez de VENTA (Lows) POR DEBAJO de la entrada
            if(currentZoneCandidate.isBuySide || currentZoneCandidate.price >= entryPrice - minDistanceToTPPoints) continue;
            if(bestTargetPriceFound == 0 || currentZoneCandidate.price > bestTargetPriceFound) { // Más cercano
                 if(initialStopLossValue > point && inpMaxDistToLiqTP_RR > 0) {
                    double rewardPotential = entryPrice - currentZoneCandidate.price;
                    if(rewardPotential / initialStopLossValue > inpMaxDistToLiqTP_RR) continue;
                }
                bestTargetPriceFound = currentZoneCandidate.price;
                targetZone = currentZoneCandidate;
            }
        }
    }
    // if(targetZone.price != 0) PrintFormat("FindNextRelevantLiquidityTarget: Target '%s' @ %.5f (Str:%.1f)", targetZone.type, targetZone.price, targetZone.strength);
    return targetZone;
}


// --- ManagePartialClosures ---
void ManagePartialClosures(ulong ticket)
{
    if(!UsePartialClose || !PositionSelectByTicket(ticket)) return;

    double entryPrice    = PositionGetDouble(POSITION_PRICE_OPEN);
    double initialSLPrice= PositionGetDouble(POSITION_SL); // SL actual (podría ser BE)
    // Para calcular R, necesitamos el SL original si es posible, o asumir el actual es el riesgo base si ya está en BE.
    // Esta función se llama después de BE, así que SL puede ser entryPrice.
    // La lógica de R debería basarse en el riesgo inicial si es posible.
    // Solución: GetStoredInitialVolume() es para volumen. Necesitaríamos almacenar el SL inicial o el riesgo inicial en puntos.
    // Simplificación: si el SL actual está muy cerca de la entrada (BE), el cálculo de R no será como el inicial.
    // Esto es una limitación si no se almacena el riesgo inicial.
    // Por ahora, se usará el SL actual para el cálculo de R, entendiendo que después de BE, R ya no es el "inicial".

    double currentPrice  = PositionGetDouble(POSITION_PRICE_CURRENT);
    double currentVolume = PositionGetDouble(POSITION_VOLUME);
    long   type          = PositionGetInteger(POSITION_TYPE);
    double point         = SymbolInfoDouble(Symbol(), SYMBOL_POINT);
    double initialVolumeStored = GetStoredInitialVolume(ticket);
    if(initialVolumeStored <= 0) initialVolumeStored = currentVolume; // Fallback
    if(initialVolumeStored <= 0 || currentVolume < SymbolInfoDouble(Symbol(),SYMBOL_VOLUME_MIN)) return;


    double riskInPrice = MathAbs(entryPrice - initialSLPrice); // Usar el SL actual
    if(riskInPrice < point * 1.0) return; // Riesgo demasiado pequeño o SL en la entrada

    double profitInPrice;
    if(type == POSITION_TYPE_BUY) profitInPrice = currentPrice - entryPrice;
    else profitInPrice = entryPrice - currentPrice;

    double currentRR = (profitInPrice > 0 && riskInPrice > point) ? (profitInPrice / riskInPrice) : 0;

    int ticketFlagIndex = FindTicketIndex(ticket); // Usar el índice real del ticket
    if(ticketFlagIndex == -1 && ArraySize(g_positionTickets) < ArraySize(g_partialClosedFlags)) { // Si no está, pero hay espacio en flags (raro)
        // No hacer nada con parciales si el ticket no está en el sistema de volumen
    } else if (ticketFlagIndex == -1) { // Si no está y no hay espacio
         ticketFlagIndex = (int)(ticket % ArraySize(g_partialClosedFlags)); // Fallback a hash simple, menos fiable
    }


    // Parcial 1
    if(g_partialClosedFlags[ticketFlagIndex] == 0 && currentRR >= PartialClose1_RR)
    {
        double closeVol = NormalizeDouble(initialVolumeStored * (PartialClose1_Percent / 100.0), 2);
        closeVol = MathMax(SymbolInfoDouble(Symbol(),SYMBOL_VOLUME_MIN), MathRound(closeVol / SymbolInfoDouble(Symbol(),SYMBOL_VOLUME_STEP)) * SymbolInfoDouble(Symbol(),SYMBOL_VOLUME_STEP));
        if(closeVol > 0 && currentVolume - closeVol >= SymbolInfoDouble(Symbol(),SYMBOL_VOLUME_MIN) * 0.99 && closeVol < currentVolume)
        {
            // PrintFormat("ManagePartials: Attempting Partial 1 for #%I64u. Vol: %.2f (CurrentRR: %.2f >= TargetRR: %.2f)", ticket, closeVol, currentRR, PartialClose1_RR);
            if(trade.PositionClosePartial(ticket, closeVol)) {
                // PrintFormat("ManagePartials: Partial 1 (%.0f%%) for #%I64u CLOSED. Vol: %.2f", PartialClose1_Percent, ticket, closeVol);
                g_partialClosedFlags[ticketFlagIndex] = 1;
                // Mover SL a BE+1 después del primer parcial si no está ya
                if(PositionSelectByTicket(ticket)) { // Re-seleccionar
                    double slActual = PositionGetDouble(POSITION_SL);
                    double tpActual = PositionGetDouble(POSITION_TP);
                    double beLevelTarget = entryPrice + (type == POSITION_TYPE_BUY ? point : -point); // BE + 1 punto
                    if((type == POSITION_TYPE_BUY && beLevelTarget > slActual) || (type == POSITION_TYPE_SELL && beLevelTarget < slActual)) {
                        if(trade.PositionModify(ticket, NormalizeDouble(beLevelTarget,_Digits), tpActual)) {
                            // PrintFormat("ManagePartials: SL for #%I64u moved to BE+1 (%.5f) after Partial 1.", ticket, beLevelTarget);
                        } // else PrintError
                    }
                }
            } // else PrintError
        }
    }

    // Re-evaluar después del primer parcial (si ocurrió)
    if(!PositionSelectByTicket(ticket)) return; // Posición podría haberse cerrado completamente si el vol era pequeño
    currentPrice  = PositionGetDouble(POSITION_PRICE_CURRENT);
    currentVolume = PositionGetDouble(POSITION_VOLUME);
    if(currentVolume < SymbolInfoDouble(Symbol(),SYMBOL_VOLUME_MIN)) return;

    if(type == POSITION_TYPE_BUY) profitInPrice = currentPrice - entryPrice; else profitInPrice = entryPrice - currentPrice;
    currentRR = (profitInPrice > 0 && riskInPrice > point) ? (profitInPrice / riskInPrice) : 0;

    // Parcial 2
    if(g_partialClosedFlags[ticketFlagIndex] == 1 && currentRR >= PartialClose2_RR)
    {
        double closeVol = NormalizeDouble(initialVolumeStored * (PartialClose2_Percent / 100.0), 2); // % del INICIAL
        closeVol = MathMax(SymbolInfoDouble(Symbol(),SYMBOL_VOLUME_MIN), MathRound(closeVol / SymbolInfoDouble(Symbol(),SYMBOL_VOLUME_STEP)) * SymbolInfoDouble(Symbol(),SYMBOL_VOLUME_STEP));
        if(closeVol > 0 && currentVolume - closeVol >= SymbolInfoDouble(Symbol(),SYMBOL_VOLUME_MIN) * 0.99 && closeVol < currentVolume)
        {
            // PrintFormat("ManagePartials: Attempting Partial 2 for #%I64u. Vol: %.2f (CurrentRR: %.2f >= TargetRR: %.2f)", ticket, closeVol, currentRR, PartialClose2_RR);
            if(trade.PositionClosePartial(ticket, closeVol)) {
                // PrintFormat("ManagePartials: Partial 2 (%.0f%%) for #%I64u CLOSED. Vol: %.2f", PartialClose2_Percent, ticket, closeVol);
                g_partialClosedFlags[ticketFlagIndex] = 2; // Activar trailing agresivo
            } // else PrintError
        }
    }
}

// --- ApplyFractalTrailing ---
void ApplyFractalTrailing(ulong ticket, int fractalDepth, double bufferPips, int searchBarsAfterEntry)
{
    if (!UseFractalStopHuntTrailing || !PositionSelectByTicket(ticket)) return;

    long posType = PositionGetInteger(POSITION_TYPE);
    datetime openTime = (datetime)PositionGetInteger(POSITION_TIME);
    double currentSL = PositionGetDouble(POSITION_SL);
    double currentTP = PositionGetDouble(POSITION_TP);
    if(currentSL == 0.0 && posType == POSITION_TYPE_BUY) currentSL = -1e9; // Un valor muy bajo si no hay SL
    if(currentSL == 0.0 && posType == POSITION_TYPE_SELL) currentSL = 1e9; // Un valor muy alto

    int depthActual = MathMax(1, fractalDepth); // Mínimo 1 (fractal 3 barras)
    int digits = _Digits;
    double point = SymbolInfoDouble(Symbol(), SYMBOL_POINT);
    double pipsFactor = ((digits==3||digits==5) && point < 0.001) ? 10.0 : 1.0;
    double bufferPts = bufferPips * point * pipsFactor; if(bufferPts<=0 && point >0) bufferPts=bufferPips*point; else if(bufferPts<=0) bufferPts=bufferPips*0.0001*pipsFactor;

    MqlRates ratesM15[];
    int barsToCopyM15 = MathMax(searchBarsAfterEntry, depthActual * 2 + 5);
    if(CopyRates(Symbol(), PERIOD_M15, 0, barsToCopyM15, ratesM15) < depthActual*2+1) return;
    ArraySetAsSeries(ratesM15, true); // ratesM15[0] es la vela M15 actual

    double fractalLevelFound = 0;
    datetime fractalTimeFound = 0;

    // Buscar el fractal MÁS RECIENTE válido después de la apertura (o cerca)
    for (int i = depthActual; i < ArraySize(ratesM15) - depthActual; i++) // i es la barra central del fractal
    {
        if(ratesM15[i].time < openTime - PeriodSeconds(PERIOD_M15)*(depthActual+1)) continue; // Fractal no demasiado antes de la apertura
        if(ratesM15[i].time > TimeCurrent() - PeriodSeconds(PERIOD_M15)*depthActual ) continue; // Fractal debe estar formado (no en las últimas 'depthActual' velas)


        bool isFractalOK = true;
        double levelCand = 0;
        if (posType == POSITION_TYPE_BUY) { // Buscamos fractal LOW para trailing de compra
            levelCand = ratesM15[i].low;
            for (int j = 1; j <= depthActual; j++) if (ratesM15[i-j].low < levelCand || ratesM15[i+j].low < levelCand) {isFractalOK = false; break;}
        } else { // Buscamos fractal HIGH para trailing de venta
            levelCand = ratesM15[i].high;
            for (int j = 1; j <= depthActual; j++) if (ratesM15[i-j].high > levelCand || ratesM15[i+j].high > levelCand) {isFractalOK = false; break;}
        }

        if (isFractalOK) {
            if(fractalTimeFound == 0 || ratesM15[i].time > fractalTimeFound) { // Tomar el más reciente
                 fractalLevelFound = levelCand;
                 fractalTimeFound = ratesM15[i].time;
            }
        }
    }

    if (fractalLevelFound != 0) {
        double newSL = 0;
        if (posType == POSITION_TYPE_BUY) newSL = fractalLevelFound - bufferPts;
        else newSL = fractalLevelFound + bufferPts;
        newSL = NormalizeDouble(newSL, digits);

        bool modify = false;
        if (posType == POSITION_TYPE_BUY && newSL > currentSL) modify = true;
        if (posType == POSITION_TYPE_SELL && newSL < currentSL) modify = true;

        if(modify) {
            double currentPriceForCheck = (posType == POSITION_TYPE_BUY) ? SymbolInfoDouble(Symbol(), SYMBOL_BID) : SymbolInfoDouble(Symbol(), SYMBOL_ASK);
            if((posType == POSITION_TYPE_BUY && newSL < currentPriceForCheck - point*5) || (posType == POSITION_TYPE_SELL && newSL > currentPriceForCheck + point*5 )) { // No demasiado cerca
                if (trade.PositionModify(ticket, newSL, currentTP)) {
                    // PrintFormat("FractalTrail: #%I64u SL to %.5f (Fractal M15 @ %s)", ticket, newSL, TimeToString(fractalTimeFound));
                } // else PrintError
            }
        }
    }
}

// --- ApplyStandardTrailing ---
void ApplyStandardTrailing(ulong ticket, double trailingPips)
{
    if (!UseTrailingStop || trailingPips <= 0 || !PositionSelectByTicket(ticket)) return;

    long posType = PositionGetInteger(POSITION_TYPE);
    double openPrice = PositionGetDouble(POSITION_PRICE_OPEN);
    double currentSL = PositionGetDouble(POSITION_SL);
    double currentTP = PositionGetDouble(POSITION_TP);
    double currentPrice = PositionGetDouble(POSITION_PRICE_CURRENT); // Precio actual de la posición

    if(currentSL == 0.0 && posType == POSITION_TYPE_BUY) currentSL = -1e9;
    if(currentSL == 0.0 && posType == POSITION_TYPE_SELL) currentSL = 1e9;

    double point = SymbolInfoDouble(Symbol(), SYMBOL_POINT);
    int digits = _Digits;
    double pipsFactor = ((digits==3||digits==5) && point < 0.001) ? 10.0 : 1.0;
    double trailingDistPoints = trailingPips * point * pipsFactor; if(trailingDistPoints<=0 && point >0) trailingDistPoints = trailingPips*point; else if(trailingDistPoints<=0) trailingDistPoints = trailingPips*0.0001*pipsFactor;


    double newSL = 0;
    if(posType == POSITION_TYPE_BUY) {
        // Para una compra, el SL debe estar por debajo del precio actual
        // Y solo se mueve si el precio actual - trailingDistance es MEJOR (más alto) que el SL actual
        // Y si la posición está en ganancia.
        if(currentPrice > openPrice + trailingDistPoints) { // Asegurar que está en ganancia suficiente para el trailing
            newSL = currentPrice - trailingDistPoints;
            if(newSL > currentSL) { // Nuevo SL es mejor
                if(trade.PositionModify(ticket, NormalizeDouble(newSL, digits), currentTP)) {
                    // PrintFormat("StdTrail: #%I64u Buy SL to %.5f", ticket, newSL);
                } // else PrintError
            }
        }
    } else { // Venta
        if(currentPrice < openPrice - trailingDistPoints) {
            newSL = currentPrice + trailingDistPoints;
            if(newSL < currentSL) { // Nuevo SL es mejor
                if(trade.PositionModify(ticket, NormalizeDouble(newSL, digits), currentTP)) {
                    // PrintFormat("StdTrail: #%I64u Sell SL to %.5f", ticket, newSL);
                } // else PrintError
            }
        }
    }
}

// --- ApplyTrailingStops (Hub) ---
void ApplyTrailingStops(ulong ticket)
{
    if(!PositionSelectByTicket(ticket)) return;

    int ticketFlagIndex = FindTicketIndex(ticket);
    if(ticketFlagIndex == -1) ticketFlagIndex = (int)(ticket % ArraySize(g_partialClosedFlags)); // Fallback


    // Prioridad al Trailing Fractal si está activo
    if(UseFractalStopHuntTrailing) {
        ApplyFractalTrailing(ticket, FractalTrailingDepth, FractalTrailingBufferPips, FractalTrailingSearchBars);
        return; // Si se aplica fractal, no aplicar otros este tick
    }

    // Si no, y si el segundo parcial se ha alcanzado, usar Trailing "Adaptativo" (que aquí es el estándar con distancia dinámica)
    // "AdvancedAdaptiveTrailing" no fue implementado como una lógica separada compleja, así que usamos el estándar.
    if(UsePartialClose && g_partialClosedFlags[ticketFlagIndex] >= 2 && UseTrailingStop) {
        ApplyStandardTrailing(ticket, TrailingDistancePips); // Usar input de trailing estándar
        return;
    }

    // Si no, el Trailing Estándar normal (si está activo y no se aplicó fractal ni adaptativo por parciales)
    if(UseTrailingStop) {
        ApplyStandardTrailing(ticket, TrailingDistancePips);
    }
}


// --- ManageRisk (Hub Principal de Gestión de Trades) ---
void ManageRisk()
{
    int totalOpenPositions = PositionsTotal();
    for(int i = totalOpenPositions - 1; i >= 0; i--)
    {
        ulong currentTicket = PositionGetTicket(i);
        if(!PositionSelectByTicket(currentTicket) || PositionGetInteger(POSITION_MAGIC) != MagicNumberEA || PositionGetString(POSITION_SYMBOL) != Symbol())
        {
            continue;
        }

        bool isTradeLong = (PositionGetInteger(POSITION_TYPE) == POSITION_TYPE_BUY);
        double entryP = PositionGetDouble(POSITION_PRICE_OPEN);
        double currentSL_Price = PositionGetDouble(POSITION_SL);
        double currentTP_Price = PositionGetDouble(POSITION_TP);
        double currentMarketPrice = isTradeLong ? SymbolInfoDouble(Symbol(), SYMBOL_BID) : SymbolInfoDouble(Symbol(), SYMBOL_ASK);
        int ticketIdxFlag = FindTicketIndex(currentTicket);
        if(ticketIdxFlag == -1) ticketIdxFlag = (int)(currentTicket % ArraySize(g_partialClosedFlags));


        // 1. Invalidación Temprana
        if(inpEnableEarlyInvalidation)
        {
            bool ideaIsInvalid = false; string reasonInvalid = "";
            // ChoCH en TF de invalidación contra el trade
            if(DetectChoCH(inpInvalidation_TF, 1, !isTradeLong, inpInvalidation_Lookback)) {
                ideaIsInvalid = true; reasonInvalid = "ChoCH " + EnumToString(inpInvalidation_TF) + " contra";
            }
            // Cambio de estructura general en TF de invalidación (ej. M15)
            if(!ideaIsInvalid && inpInvalidation_TF == PERIOD_M15) { // Asumiendo g_m15Structure está actualizada
                if((isTradeLong && g_m15Structure == MSS_BEARISH) || (!isTradeLong && g_m15Structure == MSS_BULLISH)) {
                    ideaIsInvalid = true; reasonInvalid = "MSS M15 (" + EnumToString(g_m15Structure) + ") contra";
                }
            } // Podría añadirse para otros TFs si es necesario

            if(ideaIsInvalid) {
                // PrintFormat("ManageRisk: #%I64u INVALIDADA (%s). Cerrando.", currentTicket, reasonInvalid);
                if(trade.PositionClose(currentTicket)) {
                    // PrintFormat("ManageRisk: #%I64u cerrada por invalidación.", currentTicket);
                    if(inpResetFlagsOnEarlyClose) {
                        if(ticketIdxFlag >=0 && ticketIdxFlag < ArraySize(g_partialClosedFlags)) g_partialClosedFlags[ticketIdxFlag] = 0;
                        RemoveStoredVolume(currentTicket);
                    }
                } // else PrintError
                continue; // Trade cerrado o intento de cierre, pasar al siguiente
            }
        }

        // 2. Break Even
        if(UseBreakEven && currentSL_Price != 0) // Solo si hay SL inicial
        {
            bool isAlreadyBE = (isTradeLong && currentSL_Price >= entryP) || (!isTradeLong && currentSL_Price <= entryP);
            double point = SymbolInfoDouble(Symbol(), SYMBOL_POINT);
            int digits = _Digits;
            double pipsFactorBE = ((digits==3||digits==5) && point < 0.001) ? 10.0 : 1.0;
            double profitPipsBE = 0;
            if(isTradeLong) profitPipsBE = (currentMarketPrice - entryP) / (point * pipsFactorBE);
            else profitPipsBE = (entryP - currentMarketPrice) / (point * pipsFactorBE);

            if(!isAlreadyBE && profitPipsBE >= BreakEvenPips) {
                double beLevelPrice = entryP + (isTradeLong ? point*pipsFactorBE : -point*pipsFactorBE); // BE + 1 pip
                beLevelPrice = NormalizeDouble(beLevelPrice, digits);
                if((isTradeLong && beLevelPrice > currentSL_Price) || (!isTradeLong && beLevelPrice < currentSL_Price)) {
                    if(trade.PositionModify(currentTicket, beLevelPrice, currentTP_Price)) {
                        // PrintFormat("ManageRisk: #%I64u BE a %.5f", currentTicket, beLevelPrice);
                        currentSL_Price = beLevelPrice; // Actualizar para lógica posterior
                    } // else PrintError
                }
            }
        }

        // 3. Cierres Parciales
        if(UsePartialClose && currentSL_Price != 0) { // Necesita SL para calcular R
            ManagePartialClosures(currentTicket);
            // Re-seleccionar por si se cerró o modificó
            if(!PositionSelectByTicket(currentTicket)) continue;
            currentSL_Price = PositionGetDouble(POSITION_SL); // Actualizar SL por si BE se aplicó en parciales
            currentTP_Price = PositionGetDouble(POSITION_TP);
        }

        // 4. Trailing Stops
        ApplyTrailingStops(currentTicket);

    } // Fin del bucle de posiciones

    // Limpieza de g_positionTickets y g_initialVolumes para posiciones que ya no existen
    for(int k = ArraySize(g_positionTickets) - 1; k >= 0; k--) {
        if(ArraySize(g_positionTickets) > k && g_positionTickets[k] != 0) {
             if (!PositionSelectByTicket(g_positionTickets[k])) {
                RemoveStoredVolume(g_positionTickets[k]);
            }
        } else if (ArraySize(g_positionTickets) <= k) break;
    }
}

//+------------------------------------------------------------------+
//| OnTick - Función Principal del EA, se ejecuta en cada tick       |
//+------------------------------------------------------------------+
void OnTick()
{
    datetime currentTime = TimeCurrent(); // Tiempo actual para todas las operaciones del tick

    // --- Control de Frecuencia para Cálculos Pesados ---
    // g_lastFullUpdateTime y g_updateFrequencySeconds son globales
    bool runFullUpdate = false;
    if (currentTime >= g_lastFullUpdateTime + g_updateFrequencySeconds)
    {
        g_lastFullUpdateTime = currentTime;
        runFullUpdate = true;
    }

    // --- Reset Diario de Contadores y Estados ---
    static datetime static_OnTick_lastProcessingDay = 0; // Variable estática específica para OnTick
    MqlDateTime dtCurrent_OnTick_forDailyReset, dtLast_OnTick_forDailyReset; // Structs locales para esta sección

    TimeToStruct(currentTime, dtCurrent_OnTick_forDailyReset);
    if(static_OnTick_lastProcessingDay != 0) {
        TimeToStruct(static_OnTick_lastProcessingDay, dtLast_OnTick_forDailyReset);
    }

    if(static_OnTick_lastProcessingDay == 0 || // Primera ejecución del EA o cambio de día
       dtLast_OnTick_forDailyReset.day != dtCurrent_OnTick_forDailyReset.day ||
       dtLast_OnTick_forDailyReset.mon != dtCurrent_OnTick_forDailyReset.mon ||
       dtLast_OnTick_forDailyReset.year != dtCurrent_OnTick_forDailyReset.year )
    {
        PrintFormat("%s: Nuevo Día de Trading detectado: %s. Reseteando contadores.", InpEAName, TimeToString(currentTime, TIME_DATE));
        g_tradesToday = 0;
        g_NYSilverBulletTradesToday = 0;
        if(ArraySize(g_partialClosedFlags) > 0) ArrayInitialize(g_partialClosedFlags, 0);

        // Resetear estados de procesamiento de sesión y H/L de sesión
        g_AsiaSessionProcessed = false; g_LondonSessionProcessed = false; g_NYSessionProcessed = false;
        g_AsiaHigh = 0; g_AsiaLow = 0; g_LondonHigh = 0; g_LondonLow = 0; g_NYHigh = 0; g_NYLow = 0;
        g_AsiaOpenTimeActual = 0; g_LondonOpenTimeActual = 0; g_NYOpenTimeActual = 0;

        if(runFullUpdate || static_OnTick_lastProcessingDay == 0) { // Forzar UpdateOldHighsLows al inicio del día
            UpdateOldHighsLows();
        }
        static_OnTick_lastProcessingDay = currentTime; // Actualizar el día de último procesamiento
    }

    // --- Actualizar Tiempos y H/L de Sesiones Actuales ---
    // Esta función debe usar currentTime y actualizar las variables globales g_AsiaHigh, g_AsiaLow, etc.
    UpdateActualSessionHighsLows(currentTime);


    // --- Actualizar Estados de Ventanas de Tiempo (Killzones, Silver Bullet) ---
    // Usar la MqlDateTime ya obtenida para el reset diario para evitar múltiples llamadas a TimeToStruct
    // MqlDateTime dtCurrentForTimeWindows; // Ya no es necesaria si usamos dtCurrent_OnTick_forDailyReset
    // TimeToStruct(currentTime, dtCurrentForTimeWindows);

    if(inpEnableKillzonePonderation || FilterBySessions)
    {
        g_isInGoldenKillzoneHour = false;
        int currentHourLocal = dtCurrent_OnTick_forDailyReset.hour;
        int currentMinuteLocal = dtCurrent_OnTick_forDailyReset.min;

        datetime londonKZStartTime_calc, londonKZEndTime_calc, londonGoldenEndTime_calc;
        CalculateSessionTimesToday(currentTime, LondonOpenHour, LondonOpenMinute, LondonCloseHour, LondonCloseMinute, londonKZStartTime_calc, londonKZEndTime_calc);
        londonGoldenEndTime_calc = londonKZStartTime_calc + inpKz_GoldenHourMinutes * 60;
        if (currentTime >= londonKZStartTime_calc && currentTime < londonGoldenEndTime_calc && currentTime < londonKZEndTime_calc) {
            g_isInGoldenKillzoneHour = true;
        }

        if (!g_isInGoldenKillzoneHour && inpEnableKillzonePonderation) { // Solo chequear NY si no estamos en Golden London
            datetime nyKZStartTime_calc, nyKZEndTime_calc, nyGoldenEndTime_calc;
            CalculateSessionTimesToday(currentTime, NYOpenHour, NYOpenMinute, NYCloseHour, NYCloseMinute, nyKZStartTime_calc, nyKZEndTime_calc);
            nyGoldenEndTime_calc = nyKZStartTime_calc + inpKz_GoldenHourMinutes * 60;
            if (currentTime >= nyKZStartTime_calc && currentTime < nyGoldenEndTime_calc && currentTime < nyKZEndTime_calc) {
                 g_isInGoldenKillzoneHour = true;
            }
        }
    } else {
        g_isInGoldenKillzoneHour = false;
    }
    g_isInNYSilverBulletWindow = IsNYSilverBulletWindowActive(currentTime);


    // --- Filtro General por Sesiones (si está activado) ---
    if(FilterBySessions)
    {
      bool isInActiveTradingSession = false; // Renombrada para claridad
      datetime tempSessionOpen, tempSessionClose; // Variables locales para esta sección

      CalculateSessionTimesToday(currentTime, AsiaOpenHour, AsiaOpenMinute, AsiaCloseHour, AsiaCloseMinute, tempSessionOpen, tempSessionClose);
      if(currentTime >= tempSessionOpen && currentTime < tempSessionClose) isInActiveTradingSession = true;

      if(!isInActiveTradingSession) {
          CalculateSessionTimesToday(currentTime, LondonOpenHour, LondonOpenMinute, LondonCloseHour, LondonCloseMinute, tempSessionOpen, tempSessionClose);
          if(currentTime >= tempSessionOpen && currentTime < tempSessionClose) isInActiveTradingSession = true;
      }
      if(!isInActiveTradingSession) {
          CalculateSessionTimesToday(currentTime, NYOpenHour, NYOpenMinute, NYCloseHour, NYCloseMinute, tempSessionOpen, tempSessionClose);
          if(currentTime >= tempSessionOpen && currentTime < tempSessionClose) isInActiveTradingSession = true;
      }
      if(!isInActiveTradingSession) {
        if(PositionsTotal() == 0) {
            // Print("OnTick: Fuera de Sesión de Trading configurada. No se buscan nuevas entradas.");
            return; // Salir si no estamos en sesión y no hay trades que gestionar
        }
      }
    }

    // --- Actualizaciones de Análisis (con control de frecuencia 'runFullUpdate') ---
    if(runFullUpdate)
    {
        if(UseDailyBias) ComputeD1Bias();
        if(UseH4Bias || UseDailyBias) ComputeH4Bias();

        g_m15Structure = DetectMarketStructure(PERIOD_M15, FractalLookback_M15);
        g_h1Structure  = DetectMarketStructure(PERIOD_H1, FractalLookback_M15 * 2); // Ajustar lookback para H1

        DetectLiquidity(); // Llama internamente a UpdateOldHighsLows y UpdateSessionHighsLows (para zonas pasadas)
        UpdatePriceNarrativeContext(); // Debe ir DESPUÉS de DetectLiquidity
        UpdateAndStoreStdDevProjections(); // La función interna controla su propia frecuencia

        DetectFairValueGaps(inpFVG_DetectionTF);
        DetectOrderBlocks(inpOB_DetectionTF);
        DetectBreakerBlocks(inpOB_DetectionTF, inpOB_DetectionTF);
    }

    // --- Gestión de Posiciones Abiertas (se ejecuta en cada tick si hay posiciones) ---
    if(PositionsTotal() > 0)
    {
       ManageRisk(); // Incluye invalidación temprana, BE, parciales, trailings
       return; // No buscar nuevas entradas si hay posiciones abiertas o gestionándose
    }

    // --- Lógica de Búsqueda de Nuevas Entradas ---
    if(g_tradesToday >= MaxTradesPerDay) {
        // if(runFullUpdate && (dtCurrent_OnTick_forDailyReset.sec == 0)) // Loguear solo una vez por minuto si se alcanzó el límite
        //    PrintFormat("OnTick: Límite de trades diarios (%d) alcanzado.", MaxTradesPerDay);
        return;
    }

    // Prioridad 1: Silver Bullet
    if(g_isInNYSilverBulletWindow && inpEnableNYSilverBullet)
    {
        // SB necesita datos de liquidez y FVG relativamente frescos
        if(runFullUpdate || (currentTime - g_lastFullUpdateTime > g_updateFrequencySeconds / 3) ) { // Ejecutar si datos están semi-frescos
            CheckSilverBulletSetup();
            if(PositionsTotal() > 0 || g_tradesToday >= MaxTradesPerDay) return;
        }
    }

    // Prioridad 2: Confirmación de Entrada Modelo 2022 (si está esperando)
    if(g_waitingForEntryConfirmation && inpEnableEntryConfirmationM2022)
    {
       CheckEntryConfirmationM2022();
       if(g_waitingForEntryConfirmation || PositionsTotal() > 0 || g_tradesToday >= MaxTradesPerDay) return;
    }

    // Prioridad 3: Entradas Regulares Basadas en POI (CheckTradeEntries)
    // Solo llamar si se ejecutó el full update para tener la información de POIs más reciente.
    if(runFullUpdate)
    {
        // Control opcional para no operar múltiples veces en la misma vela de un TF mayor
        // datetime currentH4CandleTime = iTime(Symbol(), PERIOD_H4, 0);
        // if(g_lastTradeTimeThisSessionH4 == currentH4CandleTime && g_tradesToday > 0 && MaxTradesPerDay > 1 && g_tradesToday < MaxTradesPerDay) {
        //    // No hacer nada, ya se operó en esta vela H4 y aún no se alcanza el límite diario
        // } else {
             CheckTradeEntries(); // Esta función puede activar g_waitingForEntryConfirmation
        // }
    }
}
//+------------------------------------------------------------------+




